<!DOCTYPE html>
<html lang="English">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.60">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/icon.png"><title>How Nushell Code Gets Run | Nushell</title><meta name="description" content="A new type of shell.">
    <link rel="preload" href="/assets/style-9c9951ef.css" as="style"><link rel="stylesheet" href="/assets/style-9c9951ef.css">
    <link rel="modulepreload" href="/assets/app-c9a81c0f.js"><link rel="modulepreload" href="/assets/framework-344bb0e4.js"><link rel="modulepreload" href="/assets/how_nushell_code_gets_run.html-532e289e.js"><link rel="modulepreload" href="/assets/how_nushell_code_gets_run.html-e0a93ddd.js">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Nushell</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/book/" class="router-link-active" aria-label="Book"><!--[--><!--]--> Book <!--[--><!--]--></a></div><div class="navbar-item"><a href="/commands/" class="" aria-label="Commands"><!--[--><!--]--> Commands <!--[--><!--]--></a></div><div class="navbar-item"><a href="/cookbook/" class="" aria-label="Cookbook"><!--[--><!--]--> Cookbook <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/" class="" aria-label="Changelog"><!--[--><!--]--> Changelog <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/book/how_nushell_code_gets_run.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/zh-CN/" class="" aria-label="中文"><!--[--><!--]--> 中文 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/de/" class="" aria-label="Deutsch"><!--[--><!--]--> Deutsch <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/es/" class="" aria-label="Español"><!--[--><!--]--> Español <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/ja/" class="" aria-label="日本語"><!--[--><!--]--> 日本語 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pt-BR/" class="" aria-label="Português do Brasil"><!--[--><!--]--> Português do Brasil <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/nushell/nushell" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/book/" class="router-link-active" aria-label="Book"><!--[--><!--]--> Book <!--[--><!--]--></a></div><div class="navbar-item"><a href="/commands/" class="" aria-label="Commands"><!--[--><!--]--> Commands <!--[--><!--]--></a></div><div class="navbar-item"><a href="/cookbook/" class="" aria-label="Cookbook"><!--[--><!--]--> Cookbook <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/" class="" aria-label="Changelog"><!--[--><!--]--> Changelog <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/book/how_nushell_code_gets_run.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/zh-CN/" class="" aria-label="中文"><!--[--><!--]--> 中文 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/de/" class="" aria-label="Deutsch"><!--[--><!--]--> Deutsch <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/es/" class="" aria-label="Español"><!--[--><!--]--> Español <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/ja/" class="" aria-label="日本語"><!--[--><!--]--> 日本語 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pt-BR/" class="" aria-label="Português do Brasil"><!--[--><!--]--> Português do Brasil <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/nushell/nushell" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/book/README.md" class="sidebar-item sidebar-heading" aria-label="Introduction"><!--[--><!--]--> Introduction <!--[--><!--]--></a><!----></li><li><a href="/book/getting_started.md" class="sidebar-item sidebar-heading" aria-label="Getting Started"><!--[--><!--]--> Getting Started <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/book/installation.html" class="sidebar-item" aria-label="Installing Nu"><!--[--><!--]--> Installing Nu <!--[--><!--]--></a><!----></li><li><a href="/book/default_shell.html" class="sidebar-item" aria-label="Default shell"><!--[--><!--]--> Default shell <!--[--><!--]--></a><!----></li><li><a href="/book/quick_tour.html" class="sidebar-item" aria-label="Quick Tour"><!--[--><!--]--> Quick Tour <!--[--><!--]--></a><!----></li><li><a href="/book/moving_around.html" class="sidebar-item" aria-label="Moving around your system"><!--[--><!--]--> Moving around your system <!--[--><!--]--></a><!----></li><li><a href="/book/thinking_in_nu.html" class="sidebar-item" aria-label="Thinking in Nu"><!--[--><!--]--> Thinking in Nu <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/book/nu_fundamentals.md" class="sidebar-item sidebar-heading" aria-label="Nu Fundamentals"><!--[--><!--]--> Nu Fundamentals <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/book/types_of_data.html" class="sidebar-item" aria-label="Types of Data"><!--[--><!--]--> Types of Data <!--[--><!--]--></a><!----></li><li><a href="/book/loading_data.html" class="sidebar-item" aria-label="Loading data"><!--[--><!--]--> Loading data <!--[--><!--]--></a><!----></li><li><a href="/book/pipelines.html" class="sidebar-item" aria-label="Pipelines"><!--[--><!--]--> Pipelines <!--[--><!--]--></a><!----></li><li><a href="/book/working_with_strings.html" class="sidebar-item" aria-label="Working with strings"><!--[--><!--]--> Working with strings <!--[--><!--]--></a><!----></li><li><a href="/book/working_with_lists.html" class="sidebar-item" aria-label="Working with lists"><!--[--><!--]--> Working with lists <!--[--><!--]--></a><!----></li><li><a href="/book/working_with_tables.html" class="sidebar-item" aria-label="Working with tables"><!--[--><!--]--> Working with tables <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/book/programming_in_nu.md" class="sidebar-item sidebar-heading" aria-label="Programming in Nu"><!--[--><!--]--> Programming in Nu <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/book/custom_commands.html" class="sidebar-item" aria-label="Custom commands"><!--[--><!--]--> Custom commands <!--[--><!--]--></a><!----></li><li><a href="/book/aliases.html" class="sidebar-item" aria-label="Aliases"><!--[--><!--]--> Aliases <!--[--><!--]--></a><!----></li><li><a href="/book/operators.html" class="sidebar-item" aria-label="Operators"><!--[--><!--]--> Operators <!--[--><!--]--></a><!----></li><li><a href="/book/variables_and_subexpressions.html" class="sidebar-item" aria-label="Variables and Subexpressions"><!--[--><!--]--> Variables and Subexpressions <!--[--><!--]--></a><!----></li><li><a href="/book/scripts.html" class="sidebar-item" aria-label="Scripts"><!--[--><!--]--> Scripts <!--[--><!--]--></a><!----></li><li><a href="/book/modules.html" class="sidebar-item" aria-label="Modules"><!--[--><!--]--> Modules <!--[--><!--]--></a><!----></li><li><a href="/book/overlays.html" class="sidebar-item" aria-label="Overlays"><!--[--><!--]--> Overlays <!--[--><!--]--></a><!----></li><li><a href="/book/command_signature.html" class="sidebar-item" aria-label="Command signature"><!--[--><!--]--> Command signature <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/book/nu_as_a_shell.md" class="sidebar-item sidebar-heading" aria-label="Nu as a Shell"><!--[--><!--]--> Nu as a Shell <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/book/configuration.html" class="sidebar-item" aria-label="Configuration"><!--[--><!--]--> Configuration <!--[--><!--]--></a><!----></li><li><a href="/book/environment.html" class="sidebar-item" aria-label="Environment"><!--[--><!--]--> Environment <!--[--><!--]--></a><!----></li><li><a href="/book/stdout_stderr_exit_codes.html" class="sidebar-item" aria-label="Stdout, Stderr, and Exit Codes"><!--[--><!--]--> Stdout, Stderr, and Exit Codes <!--[--><!--]--></a><!----></li><li><a href="/book/escaping.html" class="sidebar-item" aria-label="Escaping to the system"><!--[--><!--]--> Escaping to the system <!--[--><!--]--></a><!----></li><li><a href="/book/3rdpartyprompts.html" class="sidebar-item" aria-label="How to configure 3rd party prompts"><!--[--><!--]--> How to configure 3rd party prompts <!--[--><!--]--></a><!----></li><li><a href="/book/shells_in_shells.html" class="sidebar-item" aria-label="Shells in shells"><!--[--><!--]--> Shells in shells <!--[--><!--]--></a><!----></li><li><a href="/book/line_editor.html" class="sidebar-item" aria-label="Reedline, Nu&#39;s line editor"><!--[--><!--]--> Reedline, Nu&#39;s line editor <!--[--><!--]--></a><!----></li><li><a href="/book/externs.html" class="sidebar-item" aria-label="Externs"><!--[--><!--]--> Externs <!--[--><!--]--></a><!----></li><li><a href="/book/custom_completions.html" class="sidebar-item" aria-label="Custom completions"><!--[--><!--]--> Custom completions <!--[--><!--]--></a><!----></li><li><a href="/book/coloring_and_theming.html" class="sidebar-item" aria-label="Coloring and Theming in Nu"><!--[--><!--]--> Coloring and Theming in Nu <!--[--><!--]--></a><!----></li><li><a href="/book/hooks.html" class="sidebar-item" aria-label="Hooks"><!--[--><!--]--> Hooks <!--[--><!--]--></a><!----></li><li><a href="/book/background_task.html" class="sidebar-item" aria-label="Background task in Nu"><!--[--><!--]--> Background task in Nu <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/book/coming_to_nu.md" class="sidebar-item sidebar-heading" aria-label="Coming to Nu"><!--[--><!--]--> Coming to Nu <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/book/coming_from_bash.html" class="sidebar-item" aria-label="Coming from Bash"><!--[--><!--]--> Coming from Bash <!--[--><!--]--></a><!----></li><li><a href="/book/coming_from_cmd.html" class="sidebar-item" aria-label="Coming from CMD.EXE"><!--[--><!--]--> Coming from CMD.EXE <!--[--><!--]--></a><!----></li><li><a href="/book/nushell_map.html" class="sidebar-item" aria-label="Nu map from other shells and domain specific languages"><!--[--><!--]--> Nu map from other shells and domain specific languages <!--[--><!--]--></a><!----></li><li><a href="/book/nushell_map_imperative.html" class="sidebar-item" aria-label="Nu map from imperative languages"><!--[--><!--]--> Nu map from imperative languages <!--[--><!--]--></a><!----></li><li><a href="/book/nushell_map_functional.html" class="sidebar-item" aria-label="Nu map from functional languages"><!--[--><!--]--> Nu map from functional languages <!--[--><!--]--></a><!----></li><li><a href="/book/nushell_operator_map.html" class="sidebar-item" aria-label="Nushell operator map"><!--[--><!--]--> Nushell operator map <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/book/design_notes.md" class="sidebar-item sidebar-heading active" aria-label="Design Notes"><!--[--><!--]--> Design Notes <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="How Nushell Code Gets Run"><!--[--><!--]--> How Nushell Code Gets Run <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#parsing-and-evaluation" class="router-link-active router-link-exact-active sidebar-item" aria-label="Parsing and Evaluation"><!--[--><!--]--> Parsing and Evaluation <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#interpreted-languages" class="router-link-active router-link-exact-active sidebar-item" aria-label="Interpreted Languages"><!--[--><!--]--> Interpreted Languages <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#compiled-languages" class="router-link-active router-link-exact-active sidebar-item" aria-label="Compiled Languages"><!--[--><!--]--> Compiled Languages <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#eval-function" class="router-link-active router-link-exact-active sidebar-item" aria-label="Eval Function"><!--[--><!--]--> Eval Function <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#implications" class="router-link-active router-link-exact-active sidebar-item" aria-label="Implications"><!--[--><!--]--> Implications <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#common-mistakes" class="router-link-active router-link-exact-active sidebar-item" aria-label="Common Mistakes"><!--[--><!--]--> Common Mistakes <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#_1-sourcing-a-dynamic-path" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. Sourcing a dynamic path"><!--[--><!--]--> 1. Sourcing a dynamic path <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#_2-write-to-a-file-and-source-it-in-a-single-script" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Write to a file and source it in a single script"><!--[--><!--]--> 2. Write to a file and source it in a single script <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#_3-change-a-directory-and-source-a-path-within" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. Change a directory and source a path within"><!--[--><!--]--> 3. Change a directory and source a path within <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#repl" class="router-link-active router-link-exact-active sidebar-item" aria-label="REPL"><!--[--><!--]--> REPL <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#parse-time-evaluation" class="router-link-active router-link-exact-active sidebar-item" aria-label="Parse-time Evaluation"><!--[--><!--]--> Parse-time Evaluation <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/book/how_nushell_code_gets_run.html#conclusion" class="router-link-active router-link-exact-active sidebar-item" aria-label="Conclusion"><!--[--><!--]--> Conclusion <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/book/advanced.md" class="sidebar-item sidebar-heading" aria-label="(Not So) Advanced"><!--[--><!--]--> (Not So) Advanced <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/book/dataframes.html" class="sidebar-item" aria-label="Dataframes"><!--[--><!--]--> Dataframes <!--[--><!--]--></a><!----></li><li><a href="/book/metadata.html" class="sidebar-item" aria-label="Metadata"><!--[--><!--]--> Metadata <!--[--><!--]--></a><!----></li><li><a href="/book/creating_errors.html" class="sidebar-item" aria-label="Creating your own errors"><!--[--><!--]--> Creating your own errors <!--[--><!--]--></a><!----></li><li><a href="/book/parallelism.html" class="sidebar-item" aria-label="Parallelism"><!--[--><!--]--> Parallelism <!--[--><!--]--></a><!----></li><li><a href="/book/plugins.html" class="sidebar-item" aria-label="Plugins"><!--[--><!--]--> Plugins <!--[--><!--]--></a><!----></li><li><a href="/book/explore.html" class="sidebar-item" aria-label="explore"><!--[--><!--]--> explore <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="how-nushell-code-gets-run" tabindex="-1"><a class="header-anchor" href="#how-nushell-code-gets-run" aria-hidden="true">#</a> How Nushell Code Gets Run</h1><p>As you probably noticed, Nushell behaves quite differently from other shells and dynamic languages. In <a href="/book/thinking_in_nu.html#think-of-nushell-as-a-compiled-language" class="">Thinking in Nu</a>, we advise you to <em>think of Nushell as a compiled language</em> but we do not give much insight into why. This section hopefully fills the gap.</p><p>First, let&#39;s give a few example which you might intuitively try but which do not work in Nushell.</p><ol><li>Sourcing a dynamic path</li></ol><div class="language-text" data-ext="text"><pre class="language-text"><code>source $&quot;($my_path)/common.nu&quot;
</code></pre></div><ol start="2"><li>Write to a file and source it in a single script</li></ol><div class="language-text" data-ext="text"><pre class="language-text"><code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu
source &quot;output.nu&quot;
</code></pre></div><ol start="3"><li>Change a directory and source a path within (even though the file exists)</li></ol><div class="language-text" data-ext="text"><pre class="language-text"><code>if (&#39;spam/foo.nu&#39; | path exists) {
    cd spam
    source-env foo.nu
}
</code></pre></div><p>The underlying reason why all of the above examples won&#39;t work is a strict separation of <strong>parsing and evaluation</strong> steps by <strong>disallowing eval function</strong>. In the rest of this section, we&#39;ll explain in detail what it means, why we&#39;re doing it, and what the implications are. The explanation aims to be as simple as possible, but it might help if you&#39;ve written a program in some language before.</p><h2 id="parsing-and-evaluation" tabindex="-1"><a class="header-anchor" href="#parsing-and-evaluation" aria-hidden="true">#</a> Parsing and Evaluation</h2><h3 id="interpreted-languages" tabindex="-1"><a class="header-anchor" href="#interpreted-languages" aria-hidden="true">#</a> Interpreted Languages</h3><p>Let&#39;s start with a simple &quot;hello world&quot; Nushell program:</p><div class="language-text" data-ext="text"><pre class="language-text"><code># hello.nu

print &quot;Hello world!&quot;
</code></pre></div><p>When you run <code>nu hello.nu</code>, Nushell&#39;s interpreter directly runs the program and prints the result to the screen. This is similar (on the highest level) to other languages that are typically interpreted, such as Python or Bash. If you write a similar &quot;hello world&quot; program in any of these languages and call <code>python hello.py</code> or <code>bash hello.bash</code>, the result will be printed to the screen. We can say that interpreters take the program in some representation (e.g., a source code), run it, and give you the result:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>source code --&gt; interpreting --&gt; result
</code></pre></div><p>Under the hood, Nushell&#39;s interpreter is split into two parts, like this:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>1. source code --&gt; parsing --&gt; Intermediate Representation (IR)
2. IR --&gt; evaluating --&gt; result
</code></pre></div><p>First, the source code is analyzed by the parser and converted into an intermediate representation (IR), which in Nushell&#39;s case are just some data structures. Then, these data structures are passed to the engine which evaluates them and produces the result. This is nothing unusual. For example, Python&#39;s source code is typically converted into <a href="https://en.wikipedia.org/wiki/Bytecode" target="_blank" rel="noopener noreferrer">bytecode<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> before evaluation.</p><h3 id="compiled-languages" tabindex="-1"><a class="header-anchor" href="#compiled-languages" aria-hidden="true">#</a> Compiled Languages</h3><p>On the other side are languages that are typically &quot;compiled&quot;, such as C, C++, or Rust. Assuming a simple <a href="https://doc.rust-lang.org/stable/book/ch01-02-hello-world.html" target="_blank" rel="noopener noreferrer">&quot;hello world&quot;<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> in Rust</p><div class="language-rust" data-ext="rs"><pre class="language-rust"><code><span class="token comment">// main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>you first need to <em>compile</em> the program into <a href="https://en.wikipedia.org/wiki/Machine_code" target="_blank" rel="noopener noreferrer">machine code instructions<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> and store the binary file to a disk (<code>rustc main.rs</code>). Then, to produce a result, you need to run the binary (<code>./main</code>), which passes the instructions to the CPU:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>1. source code --&gt; compiler --&gt; machine code
2. machine code --&gt; CPU --&gt; result
</code></pre></div><p>You can see the compile-run sequence is not that much different from the parse-evaluate sequence of an interpreter. You begin with a source code, parse (or compile) it into some IR (or machine code), then evaluate (or run) the IR to get a result. You could think of machine code as just another type of IR and the CPU as its interpreter.</p><p>One big difference, however, between interpreted and compiled languages is that interpreted languages typically implement an <em>eval function</em> while compiled languages do not. What does it mean?</p><h3 id="eval-function" tabindex="-1"><a class="header-anchor" href="#eval-function" aria-hidden="true">#</a> Eval Function</h3><p>Most languages considered as &quot;dynamic&quot; or &quot;interpreted&quot; have an eval function, for example Python (it has two, <a href="https://docs.python.org/3/library/functions.html#eval" target="_blank" rel="noopener noreferrer">eval<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> and <a href="https://docs.python.org/3/library/functions.html#exec" target="_blank" rel="noopener noreferrer">exec<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>) or <a href="https://linux.die.net/man/1/bash" target="_blank" rel="noopener noreferrer">Bash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>. It is used to take source code and interpret it within a running interpreter. This can get a bit confusing, so let&#39;s give a Python example:</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token comment"># hello_eval.py</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span>
<span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">&quot;print(&#39;Hello eval!&#39;)&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>When you run the file (<code>python hello_eval.py</code>), you&#39;ll see two messages: &quot;Hello world!&quot; and &quot;Hello eval!&quot;. Here is what happened:</p><ol><li>Parse the whole source code</li><li>Evaluate <code>print(&quot;Hello world!&quot;)</code></li><li>To evaluate <code>eval(&quot;print(&#39;Hello eval!&#39;)&quot;)</code>: 3.1. Parse <code>print(&#39;Hello eval!&#39;)</code> 3.2. Evaluate <code>print(&#39;Hello eval!&#39;)</code></li></ol><p>Of course, you can have more fun and try <code>eval(&quot;eval(\&quot;print(&#39;Hello eval!&#39;)\&quot;)&quot;)</code> and so on...</p><p>You can see the eval function adds a new &quot;meta&quot; layer into the code execution. Instead of parsing the whole source code, then evaluating it, there is an extra parse-eval step during the evaluation. This means that the IR produced by the parser (whatever it is) can be further modified during the evaluation.</p><p>We&#39;ve seen that without <code>eval</code>, the difference between compiled and interpreted languages is actually not that big. This is exactly what we mean by <a href="https://www.nushell.sh/book/thinking_in_nu.html#think-of-nushell-as-a-compiled-language" target="_blank" rel="noopener noreferrer">thinking of Nushell as a compiled language<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>: Despite Nushell being an interpreted language, its lack of <code>eval</code> gives it characteristics and limitations typical for traditional compiled languages like C or Rust. We&#39;ll dig deeper into what it means in the next section.</p><h2 id="implications" tabindex="-1"><a class="header-anchor" href="#implications" aria-hidden="true">#</a> Implications</h2><p>Consider this Python example:</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">exec</span><span class="token punctuation">(</span><span class="token string">&quot;def hello(): print(&#39;Hello eval!&#39;)&quot;</span><span class="token punctuation">)</span>
hello<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><em>Note: We&#39;re using <code>exec</code> instead of <code>eval</code> because it can execute all valid Python code, not just expressions. The principle is similar, though.</em></p><p>What happens:</p><ol><li>Parse the whole source code</li><li>To evaluate <code>exec(&quot;def hello(): print(&#39;Hello eval!&#39;)&quot;)</code>: 2.1. Parse <code>def hello(): print(&#39;Hello eval!&#39;)</code> 2.2 Evaluate <code>def hello(): print(&#39;Hello eval!&#39;)</code></li><li>Evaluate <code>hello()</code></li></ol><p>Note, that until step 2.2, the interpreter has no idea a function <code>hello</code> exists! This makes static analysis of dynamic languages challenging. In the example, the existence of <code>hello</code> function cannot be checked just by parsing (compiling) the source code. You actually need to go and evaluate (run) the code to find out. While in a compiled language, missing function is a guaranteed compile error, in a dynamic interpreted language, it is a runtime error (which can slip unnoticed if the line calling <code>hello()</code> is, for example, behind an <code>if</code> condition and does not get executed).</p><p>In Nushell, there are <strong>exactly two steps</strong>:</p><ol><li>Parse the whole source code</li><li>Evaluate the whole source code</li></ol><p>This is the complete parse-eval sequence.</p><p>Not having <code>eval</code>-like functionality prevents <code>eval</code>-related bugs from happening. Calling a non-existent function is 100% guaranteed parse-time error in Nushell. Furthermore, after the parse step, we have a deep insight into the program and we&#39;re 100% sure it is not going to change during evaluation. This trivially allows for powerful and reliable static analysis and IDE integration which is challenging to achieve with more dynamic languages. In general, you have more peace of mind when scaling Nushell programs to bigger applications.</p><p><em>Before going into examples, one note about the &quot;dynamic&quot; and &quot;static&quot; terminology. Stuff that happens at runtime (during evaluation, after parsing) is considered &quot;dynamic&quot;. Stuff that happens before running (during parsing / compilation) is called &quot;static&quot;. Languages that have more stuff (such as <code>eval</code>, type checking, etc.) happening at runtime are sometimes called &quot;dynamic&quot;. Languages that analyze most of the information (type checking, <a href="https://doc.rust-lang.org/stable/book/ch04-00-understanding-ownership.html" target="_blank" rel="noopener noreferrer">data ownership<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, etc.) before evaluating the program are sometimes called &quot;static&quot;. The whole debate can get quite confusing, but for the purpose of this text, the main difference between a &quot;static&quot; and &quot;dynamic&quot; language is whether it has or has not the eval function.</em></p><h2 id="common-mistakes" tabindex="-1"><a class="header-anchor" href="#common-mistakes" aria-hidden="true">#</a> Common Mistakes</h2><p>By insisting on strict parse-evaluation separation, we lose much of a flexibility users expect from dynamic interpreted languages, especially other shells, such as bash, fish, zsh and others. This leads to the examples at the beginning of this page not working. Let&#39;s break them down one by one</p><p><em>Note: The following examples use <a href="/commands/docs/source.html" class=""><code>source</code></a>, but similar conclusions apply to other commands that parse Nushell source code, such as <a href="/commands/docs/use.html" class=""><code>use</code></a>, <a href="/commands/docs/overlay_use.html" class=""><code>overlay use</code></a>, <a href="/commands/docs/hide.html" class=""><code>hide</code></a>, <a href="/commands/docs/register.html" class=""><code>register</code></a> or <a href="/commands/docs/source-env.html" class=""><code>source-env</code></a>.</em></p><h3 id="_1-sourcing-a-dynamic-path" tabindex="-1"><a class="header-anchor" href="#_1-sourcing-a-dynamic-path" aria-hidden="true">#</a> 1. Sourcing a dynamic path</h3><div class="language-text" data-ext="text"><pre class="language-text"><code>source $&quot;($my_path)/common.nu&quot;
</code></pre></div><p>Let&#39;s break down what would need to happen for this to work (assuming <code>$my_path</code> is set somewhere):</p><ol><li>Parse <code>source $&quot;($my_path)/common.nu&quot;</code></li><li>To evaluate <code>source $&quot;($my_path)/common.nu&quot;</code>: 2.1. Parse <code>$&quot;($my_path)/common.nu&quot;</code> 2.2. Evaluate <code>$&quot;($my_path)/common.nu&quot;</code> to get the file name 2.3. Parse the contents of the file 2.4. Evaluate the contents of the file</li></ol><p>You can see the process is similar to the <code>eval</code> functionality we talked about earlier. Nesting parse-evaluation cycles into the evaluation is not allowed in Nushell.</p><p>To give another perspective, here is why it is helpful to <em>think of Nushell as a compiled language</em>. Instead of</p><div class="language-text" data-ext="text"><pre class="language-text"><code>let my_path = &#39;foo&#39;
source $&quot;($my_path)/common.nu&quot;
</code></pre></div><p>imagine it being written in some typical compiled language, such as C++</p><div class="language-cpp" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">my_path</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;my_path + &quot;/common.h&quot;&gt;</span></span>
</code></pre></div><p>or Rust</p><div class="language-rust!" data-ext="rust!"><pre class="language-rust!"><code>let my_path = &quot;foo&quot;;
use format!(&quot;{}::common&quot;, my_path);
</code></pre></div><p>If you&#39;ve ever written a simple program in any of these languages, you can see these examples do not make a whole lot of sense. You need to have all the source code files ready and available to the compiler beforehand.</p><h3 id="_2-write-to-a-file-and-source-it-in-a-single-script" tabindex="-1"><a class="header-anchor" href="#_2-write-to-a-file-and-source-it-in-a-single-script" aria-hidden="true">#</a> 2. Write to a file and source it in a single script</h3><div class="language-text" data-ext="text"><pre class="language-text"><code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu
source &quot;output.nu&quot;
</code></pre></div><p>Here, the sourced path is static (= known at parse-time) so everything should be fine, right? Well... no. Let&#39;s break down the sequence again:</p><ol><li>Parse the whole source code 1.1. Parse <code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu</code> 1.2. Parse <code>source &quot;output.nu&quot;</code> - 1.2.1. Open <code>output.nu</code> and parse its contents</li><li>Evaluate the whole source code 2.1. Evaluate <code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu</code> to generate <code>output.nu</code> 2.2. ...wait what???</li></ol><p>We&#39;re asking Nushell to read <code>output.nu</code> before it even exists. All the source code needs to be available to Nushell at parse-time, but <code>output.nu</code> is only generated during evaluation. Again, it helps here to <em>think of Nushell as a compiled language</em>.</p><h3 id="_3-change-a-directory-and-source-a-path-within" tabindex="-1"><a class="header-anchor" href="#_3-change-a-directory-and-source-a-path-within" aria-hidden="true">#</a> 3. Change a directory and source a path within</h3><p>(We assume the <code>spam/foo.nu</code> file exists.)</p><div class="language-text" data-ext="text"><pre class="language-text"><code>if (&#39;spam/foo.nu&#39; | path exists) {
    cd spam
    source-env foo.nu
}
</code></pre></div><p>This one is similar to the previous example. <code>cd spam</code> changes the directory <em>during evaluation</em> but <a href="/commands/docs/source-env.html" class=""><code>source-env</code></a> attempts to open and read <code>foo.nu</code> during parsing.</p><h2 id="repl" tabindex="-1"><a class="header-anchor" href="#repl" aria-hidden="true">#</a> REPL</h2><p><a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" target="_blank" rel="noopener noreferrer">REPL<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> is what happens when you run <code>nu</code> without any file. You launch an interactive prompt. By</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; some code...
</code></pre></div><p>we denote a REPL entry followed by pressing Enter. For example</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; print &quot;Hello world!&quot;
Hello world!

&gt; ls
# prints files and directories...
</code></pre></div><p>means the following:</p><ol><li>Launch <code>nu</code></li><li>Type <code>print &quot;Hello world!&quot;</code>, press Enter</li><li>Type <a href="/commands/docs/ls.html" class=""><code>ls</code></a>, press Enter</li></ol><p>Hopefully, that&#39;s clear. Now, when you press Enter, these things happen:</p><ol><li>Parse the line input</li><li>Evaluate the line input</li><li>Merge the environment (such as the current working directory) to the internal Nushell state</li><li>Wait for another input</li></ol><p>In other words, each REPL invocation is its own separate parse-evaluation sequence. By merging the environment back to the Nushell&#39;s state, we maintain continuity between the REPL invocations.</p><p>To give an example, we showed that</p><div class="language-text" data-ext="text"><pre class="language-text"><code>cd spam
source-env foo.nu
</code></pre></div><p>does not work because the directory will be changed <em>after</em> <a href="/commands/docs/source-env.html" class=""><code>source-env</code></a> attempts to read the file. Running these commands as separate REPL entries, however, works:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; cd spam

&gt; source-env foo.nu
# yay, works!
</code></pre></div><p>To see why, let&#39;s break down what happens in the example:</p><ol><li>Launch <code>nu</code></li><li>Parse <code>cd spam</code></li><li>Evaluate <code>cd spam</code></li><li><strong>Merge environment (including the current directory) into the Nushell state</strong></li><li>Parse <code>source-env foo.nu</code></li><li>Evaluate <code>source-env foo.nu</code></li><li>Merge environment (including the current directory) into the Nushell state</li></ol><p>When <a href="/commands/docs/source-env.html" class=""><code>source-env</code></a> tries to open <code>foo.nu</code> during the parsing in step 5., it can do so because the directory change from step 3. was merged into the Nushell state in step 4. and therefore is visible in the following parse-evaluation cycles.</p><h3 id="parse-time-evaluation" tabindex="-1"><a class="header-anchor" href="#parse-time-evaluation" aria-hidden="true">#</a> Parse-time Evaluation</h3><p>While it is impossible to add parsing into the evaluation, we can add <em>a little bit</em> of evaluation into parsing. This feature has been added <a href="https://github.com/nushell/nushell/pull/7436" target="_blank" rel="noopener noreferrer">only recently<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> and we&#39;re going to expand it as needed.</p><p>One pattern that this unlocks is being able to <a href="/commands/docs/source.html" class=""><code>source</code></a>/<a href="/commands/docs/use.html" class=""><code>use</code></a>/etc. a path from a &quot;variable&quot;. We&#39;ve seen that</p><div class="language-text" data-ext="text"><pre class="language-text"><code>let some_path = &#39;foo/common.nu&#39;
source $some_path
</code></pre></div><p>does not work, but we can do the following:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>const some_path = &#39;foo/common.nu&#39;
source $some_path
</code></pre></div><p>We can break down what is happening again:</p><ol><li>Parse the whole source code 1.1. Parse <code>const some_path = &#39;foo/common.nu&#39;</code> - 1.1.1. Evaluate* <code>&#39;foo/common.nu&#39;</code> and store it as a <code>some_path</code> constant 1.2. Parse <code>source $some_path</code> - 1.2.1. Evaluate* <code>$some_path</code>, see that it is a constant, fetch it - 1.2.2. Parse the <code>foo/common.nu</code> file</li><li>Evaluate the whole source code 2.1. Evaluate <code>const some_path = &#39;foo/common.nu&#39;</code> (i.e., add the <code>foo/common.nu</code> string to the runtime stack as <code>some_path</code> variable) 2.2. Evaluate <code>source $some_path</code> (i.e., evaluate the contents of <code>foo/common.nu</code>)</li></ol><p>This still does not violate our rule of not having an eval function, because an eval function adds additional parsing to the evaluation step. With parse-time evaluation we&#39;re doing the opposite.</p><p>Also, note the * in steps 1.1.1. and 1.2.1. The evaluation happening during parsing is very restricted and limited to only a small subset of what is normally allowed during a regular evaluation. For example, the following is not allowed:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>const foo_contents = (open foo.nu)
</code></pre></div><p>By allowing <em>everything</em> during parse-time evaluation, we could set ourselves up to a lot of trouble (think of generating an infinite stream in a subexpression...). Generally, only a simple expressions <em>without side effects</em> are allowed, such as string literals or integers, or composite types of these literals (records, lists, tables).</p><p>Compiled (&quot;static&quot;) languages also tend to have a way to convey some logic at compile time, be it C&#39;s preprocessor, Rust&#39;s macros, or <a href="https://kristoff.it/blog/what-is-zig-comptime" target="_blank" rel="noopener noreferrer">Zig&#39;s comptime<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>. One reason is performance (if you can do it during compilation, you save the time during runtime) which is not as important for Nushell because we always do both parsing and evaluation, we do not store the parsed result anywhere (yet?). The second reason is similar to Nushell&#39;s: Dealing with limitations caused by the absence of the eval function.</p><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h2><p>Nushell operates in a scripting language space typically dominated by &quot;dynamic&quot; &quot;interpreted&quot; languages, such as Python, bash, zsh, fish, etc. While Nushell is also &quot;interpreted&quot; in a sense that it runs the code immediately, instead of storing the intermediate representation (IR) to a disk, one feature sets it apart from the pack: It does not have an <strong>eval function</strong>. In other words, Nushell cannot parse code and manipulate its IR during evaluation. This gives Nushell one characteristic typical for &quot;static&quot; &quot;compiled&quot; languages, such as C or Rust: All the source code must be visible to the parser beforehand, just like all the source code must be available to a C or Rust compiler. For example, you cannot <a href="/commands/docs/source.html" class=""><code>source</code></a> or <a href="/commands/docs/use.html" class=""><code>use</code></a> a path computed &quot;dynamically&quot; (during evaluation). This is surprising for users of more traditional scripting languages, but it helps to <em>think of Nushell as a compiled language</em>.</p></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/nushell/nushell.github.io/edit/main/book/how_nushell_code_gets_run.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub"><!--[--><!--]--> Edit this page on GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 44101798+amtoine@users.noreply.github.com">Antoine Stevan</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: 30049909+Hofer-Julian@users.noreply.github.com">Hofer-Julian</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: kubouch@gmail.com">Jakub Žádník</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: presidento@farkas-mate.hu">Máté FARKAS</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-c9a81c0f.js" defer></script>
  </body>
</html>
