import{_ as p,z as c,A as l,X as a,C as n,T as e,$ as o,a6 as t,Q as r}from"./framework.3d018c9f.js";const u={},d=a("h1",{id:"并行",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#并行","aria-hidden":"true"},"#"),n(" 并行")],-1),i=a("p",null,"Nushell 现在已经初步支持并行运行代码了，这允许你使用更多的计算机硬件资源来处理一个流的各个元素。",-1),h=a("p",null,[n("你会注意到这些命令包含其特有的"),a("code",null,"par-"),n("命名，每一个都对应着一个非并行的版本，这允许你先轻松地以串行的风格写代码，然后再回头用几个额外的字符轻松地将串行脚本转换成并行脚本。")],-1),k=a("h2",{id:"par-each",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#par-each","aria-hidden":"true"},"#"),n(),a("code",null,"par-each")],-1),_=a("code",null,"par-each",-1),m=a("code",null,"each",-1),b=a("code",null,"each",-1),f=a("code",null,"par-each",-1),g=a("code",null,"each",-1),v=a("code",null,"par-each",-1),x=a("code",null,"each",-1),$=t(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> <span class="token function">dir</span> <span class="token operator">|</span> each <span class="token punctuation">{</span> <span class="token operator">|</span>it<span class="token operator">|</span>
    <span class="token punctuation">{</span> name: <span class="token variable">$it</span>.name, len: <span class="token punctuation">(</span>ls <span class="token variable">$it</span>.name <span class="token operator">|</span> length<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们为每个条目创建一条记录，并在其中填入目录的名称和该子目录中的文件数。</p><p>在你的机器上，时间可能有所不同。对于这台机器的当前目录来说，需要 21 毫秒的时间。</p>`,3),N=a("code",null,"each",-1),C=a("code",null,"par-each",-1),w=t(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> <span class="token function">dir</span> <span class="token operator">|</span> par-each <span class="token punctuation">{</span> <span class="token operator">|</span>it<span class="token operator">|</span>
    <span class="token punctuation">{</span> name: <span class="token variable">$it</span>.name, len: <span class="token punctuation">(</span>ls <span class="token variable">$it</span>.name <span class="token operator">|</span> length<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这台机器上，现在它的运行时间为 6 毫秒。这是一个相当大的差异!</p>`,2),B=a("code",null,"par-each",-1),E=a("code",null,"cd",-1),V=t(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> <span class="token function">dir</span> <span class="token operator">|</span> par-each <span class="token punctuation">{</span> <span class="token operator">|</span>it<span class="token operator">|</span>
    <span class="token punctuation">{</span> name: <span class="token variable">$it</span>.name, len: <span class="token punctuation">(</span>cd <span class="token variable">$it</span>.name<span class="token punctuation">;</span> <span class="token function">ls</span> <span class="token operator">|</span> length<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>`,1),y=a("code",null,"each",-1),z=a("code",null,"par-each",-1);function A(F,L){const s=r("RouterLink");return c(),l("div",null,[d,i,h,k,a("p",null,[n("最常见的并行命令是"),e(s,{to:"/book/commands/par-each.html"},{default:o(()=>[_]),_:1}),n("，它是"),e(s,{to:"/book/commands/each.html"},{default:o(()=>[m]),_:1}),n("命令的搭档。")]),a("p",null,[n("与"),e(s,{to:"/book/commands/each.html"},{default:o(()=>[b]),_:1}),n("一样，"),e(s,{to:"/book/commands/par-each.html"},{default:o(()=>[f]),_:1}),n("对管道中流入的元素进行处理，在每个元素上运行一个代码块。与"),e(s,{to:"/book/commands/each.html"},{default:o(()=>[g]),_:1}),n("不同，"),e(s,{to:"/book/commands/par-each.html"},{default:o(()=>[v]),_:1}),n("将并行地进行这些操作。")]),a("p",null,[n("假设你想计算当前目录下每个子目录下的文件数量。使用"),e(s,{to:"/book/commands/each.html"},{default:o(()=>[x]),_:1}),n("你可以这样写。")]),$,a("p",null,[n("现在，由于这个操作可以并行运行，让我们把上面的操作转换为并行的，把"),e(s,{to:"/book/commands/each.html"},{default:o(()=>[N]),_:1}),n("改为"),e(s,{to:"/book/commands/par-each.html"},{default:o(()=>[C]),_:1}),n("：")]),w,a("p",null,[n("顺便提一下：由于 "),e(s,{to:"/zh-CN/book/environment.html#%E4%BD%9C%E7%94%A8%E5%9F%9F"},{default:o(()=>[n("环境变量是有作用域的")]),_:1}),n("，你可以使用"),B,n("在多个目录中并行工作（注意 "),E,n(" 命令）：")]),V,a("p",null,[n('如果你看一下结果，你会注意到，它们每次运行返回的顺序是不同的（这取决于你系统上的硬件线程数量）。随着任务的完成，我们得到了正确的结果，如果我们希望得到结果以特定的顺序出现，我们可能需要添加额外的步骤。例如，对于上述情况，我们可能想按 "name" 字段对结果进行排序。这样，我们的脚本的'),e(s,{to:"/book/commands/each.html"},{default:o(()=>[y]),_:1}),n("和"),e(s,{to:"/book/commands/par-each.html"},{default:o(()=>[z]),_:1}),n("版本都能得到相同的结果。")])])}const T=p(u,[["render",A],["__file","parallelism.html.vue"]]);export{T as default};
