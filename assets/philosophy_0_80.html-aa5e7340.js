import{_ as o,M as n,p as s,q as l,Q as e,t as a,N as r,a1 as t}from"./framework-344bb0e4.js";const h={},d=t('<h1 id="nushell-design-philosophy" tabindex="-1"><a class="header-anchor" href="#nushell-design-philosophy" aria-hidden="true">#</a> Nushell design philosophy</h1><h2 id="core-philosophy" tabindex="-1"><a class="header-anchor" href="#core-philosophy" aria-hidden="true">#</a> Core philosophy</h2><p>Nushell is &quot;A shell-first scripting language for working with structured data flowing through pipelines&quot;.</p><p>Designs should work towards serving this goal. Those that don&#39;t should be removed or moved to optional add-ons.</p><h2 id="core-design" tabindex="-1"><a class="header-anchor" href="#core-design" aria-hidden="true">#</a> Core design</h2><h3 id="shell-first" tabindex="-1"><a class="header-anchor" href="#shell-first" aria-hidden="true">#</a> Shell-first</h3><p>Nushell should work to serve its role as a shell and a language with a focus on shells. Shell types of activities include, but aren&#39;t limited to:</p><ul><li>Running commands</li><li>Redirecting stdout/stdin/stderr</li><li>Unix-only: Properly handling signals <ul><li>Ctrl-C</li><li>Ctrl-D</li><li>and others</li></ul></li><li>Support for background tasks <ul><li>In Unix, this may mean Ctrl-Z and traditional background/foregrounding of tasks or a more modern approach</li></ul></li></ul><p>In cases where the user would reasonably have an expectation of the functionality of the shell, we should make every effort to include. If a feature would be a reasonable expectation (say ctrl-z on Unix), then we should have OS-specific functionality for that platform that meets that expectation.</p><h3 id="scripting-language" tabindex="-1"><a class="header-anchor" href="#scripting-language" aria-hidden="true">#</a> Scripting language</h3><p>The intent of Nushell&#39;s design is to be a scripting language. Scripting can take many forms, from simple pipelines to large scripts. Nushell should handle these with ease by meeting reasonable expectations in terms of:</p><ul><li>Modularity</li><li>Readability</li><li>Programming language features and convenience</li></ul><h3 id="structured-data" tabindex="-1"><a class="header-anchor" href="#structured-data" aria-hidden="true">#</a> Structured data</h3><p>In Nushell, all data is &quot;structured&quot;. For Nushell, this means that values can take shapes beyond just a simple string.</p><p>Values in Nushell can be records, lists, tables, binary data, and more. Being able to convert into structured data and work with structured data is fundamental to Nushell.</p><h3 id="pipelines" tabindex="-1"><a class="header-anchor" href="#pipelines" aria-hidden="true">#</a> Pipelines</h3><p>Nushell takes the Unix philosophy of pipelines to heart. Commands should be built with the intent of composition. Nushell enables composition via the use of pipes (<code>|</code>), just like Unix pipelines.</p><p>Composing commands, both built-in and user-defined, is a core piece of Nushell. The design of Nushell and its standard library must support both easily composing commands as well as allowing the user to easily create compose-able commands.</p><h3 id="command-philosophy" tabindex="-1"><a class="header-anchor" href="#command-philosophy" aria-hidden="true">#</a> Command philosophy</h3><p>Specifically, Nushell&#39;s philosophy about commands is represented by the following positions (these apply especially to the library of builtin commands distributed with nushell, but are also good guidance for your own commands and plugins):</p>',20),u={href:"https://peps.python.org/pep-0020/",target:"_blank",rel:"noopener noreferrer"},c=e("li",null,[e("p",null,"The aim of our library of builtin commands is to provide a collection of simple and composable primitive commands, that covers essential shell programming needs and allows virtually anything to be built via composition and creation of custom user commands and plugins. That's as opposed to maintaining an extensive catalog of more specialized commands in the core nushell codebase: more specialized functionality should exist as community-contributed libraries (e.g. plugins/nushell libraries).")],-1),p=e("li",null,[e("p",null,"If something can be done conveniently by composition of simpler commands then we do not add flags and options to do the same thing.")],-1),m=e("li",null,[e("p",null,'The primary input to a command should generally be supplied as "input", not as a positional argument. This is what enables pipeline composition.')],-1),g=e("li",null,[e("p",null,"A given command, on a given input, should generally always produce the same type of output data structure; the presence/absence/value of arguments and flags shouldn't change the output type.")],-1),f=e("li",null,[e("p",null,"Commands should not consume their entire input streams unless that is explicitly part of the functionality of that command.")],-1),b=t(`<h2 id="command-signatures-and-their-parts" tabindex="-1"><a class="header-anchor" href="#command-signatures-and-their-parts" aria-hidden="true">#</a> Command signatures and their parts</h2><h3 id="signature" tabindex="-1"><a class="header-anchor" href="#signature" aria-hidden="true">#</a> Signature</h3><p>The signature of the command describes the following:</p><ul><li>The name of the command</li><li>The usage information (documentation) for the command</li><li>The name and type of: <ul><li>Named parameters</li><li>Positional parameters</li></ul></li><li>The type of: <ul><li>Input</li><li>Output</li></ul></li></ul><h3 id="when-to-use-input" tabindex="-1"><a class="header-anchor" href="#when-to-use-input" aria-hidden="true">#</a> When to use input</h3><p>Input is intended for one or both of:</p><ul><li>Pipeline composition</li><li>Streams of data</li></ul><h3 id="when-to-use-output" tabindex="-1"><a class="header-anchor" href="#when-to-use-output" aria-hidden="true">#</a> When to use output</h3><p>All return values are output.</p><h3 id="when-to-use-positional-parameters" tabindex="-1"><a class="header-anchor" href="#when-to-use-positional-parameters" aria-hidden="true">#</a> When to use positional parameters</h3><p>Use a positional parameter when:</p><ul><li>A parameter is required</li></ul><h3 id="when-to-use-rest-parameters" tabindex="-1"><a class="header-anchor" href="#when-to-use-rest-parameters" aria-hidden="true">#</a> When to use rest parameters</h3><p>Use a rest parameter when:</p><ul><li>A command takes some number of additional optional arguments of the same type</li></ul><h3 id="when-to-use-named-parameters" tabindex="-1"><a class="header-anchor" href="#when-to-use-named-parameters" aria-hidden="true">#</a> When to use named parameters</h3><p>Use a named parameter (a flag parameter) when:</p><ul><li>The value you need is optional</li></ul><h3 id="when-to-use-a-switch-flag" tabindex="-1"><a class="header-anchor" href="#when-to-use-a-switch-flag" aria-hidden="true">#</a> When to use a switch flag</h3><p>Use a switch flag when:</p><ul><li>You need to allow the user to change the default action of the command</li></ul><h3 id="comments" tabindex="-1"><a class="header-anchor" href="#comments" aria-hidden="true">#</a> Comments</h3><p>Commands should be commented to describe their function and usage. This documentation should also cover parameters and their use.</p><h2 id="core-categories" tabindex="-1"><a class="header-anchor" href="#core-categories" aria-hidden="true">#</a> Core categories</h2><p>The core language and standard library needs to cover the following categories to support common use cases for Nushell:</p><ul><li>Filesystem</li><li>Operating system</li><li>Manipulating the environment</li><li>Parsing string data into structured data</li><li>Formatting structured data as standard string formats (CSV and JSON)</li><li>Querying, filtering, and manipulating structured data</li><li>Network connectivity <ul><li>note: Network support is fundamental because with it users can easily acquire and install Nushell extensions</li></ul></li><li>Basic formats (exact list to be determined by common use cases)</li><li>Basic date support</li></ul><p>The following categories should be moved to plugins:</p><ul><li>Database connectivity</li><li>Dataframe support</li><li>Hash functionality</li><li>Uncommon format support</li><li>Experimental commands</li><li>Supplemental random number support (eg <code>random dice</code>)</li><li>Supplemental math support from <code>math</code></li><li>Supplemental binary data functionality from <code>bytes</code></li><li>Advanced date support</li></ul><p>We should select commands to be in the core categories which meet the common use cases for Nushell. Commands that are in the core categories that are uncommon use cases should move to optional extensions.</p><h2 id="language-design" tabindex="-1"><a class="header-anchor" href="#language-design" aria-hidden="true">#</a> Language design</h2><p>Rather than describe the whole of the language here, this section describes the changes expected to come as part of 0.80 and how they differ from the 0.60 series.</p><h3 id="more-shell-functionality" tabindex="-1"><a class="header-anchor" href="#more-shell-functionality" aria-hidden="true">#</a> More shell functionality</h3><p>Being a shell-focused language means incorporating more of the expected shell-features into the language. These include:</p><p>Redirection (with common variations):</p><div class="language-text" data-ext="text"><pre class="language-text"><code>cat foo.txt &gt; bar.txt
cat foo.txt &gt;&gt; bar.txt
cat foo.txt 2&gt; bar.txt
</code></pre></div><p>Note: as of 0.72, these are currently:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>cat foo.txt out&gt; bar.txt
cat foo.txt err&gt; bar.txt
</code></pre></div><p>(note: no operator support for append currently)</p><p>Equivalent functionality for Bash logic operators:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>cat foo.txt &amp;&amp; cat bar.txt
cat foo.txt || cat bar.txt
</code></pre></div><p>Note: as of 0.72, these are currently:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>cat foo.txt; cat bar.txt
try { cat foo.txt } catch { cat bar.txt }
</code></pre></div><p>We don&#39;t have plans to support the full bash language.</p><h3 id="limited-mutation" tabindex="-1"><a class="header-anchor" href="#limited-mutation" aria-hidden="true">#</a> Limited mutation</h3><p>In 0.80, there will be a limited form of mutation that works with the local command.</p><div class="language-text" data-ext="text"><pre class="language-text"><code>mut x = 100
$x = 200
print $x
</code></pre></div><p>This will help with some patterns where people wanted to calculate something in a loop but didn&#39;t have an easy way to do so previously.</p><h3 id="splitting-closures-and-blocks" tabindex="-1"><a class="header-anchor" href="#splitting-closures-and-blocks" aria-hidden="true">#</a> Splitting closures and blocks</h3><p>Connected to mutation is the idea that blocks and closures will be separate concepts in 0.80. In the 0.60 series, these were largely both treated on under the same concept as &quot;blocks&quot;.</p><p>In the future, a block will not be a first-class value. Instead, it will be expected to be run by the command you give it to and not passed into the pipeline. This allows blocks to work with mutable variables.</p><p>Closures retain the capabilities of 0.60 and can be used as first-class values, but can&#39;t mutate variables.</p><p>Block example:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>for x in 1..100 {
  print $x
}
</code></pre></div><p>Closure example:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>ls | each { |x| $x.name + &quot;foo&quot; }
</code></pre></div><h2 id="extensions" tabindex="-1"><a class="header-anchor" href="#extensions" aria-hidden="true">#</a> Extensions</h2><p>We will need to design and implement an easy-to-use extension mechanism that allows people to extend Nushell with additional functionality. This will be important both for helping shrink the core Nushell down but also to make it easy for contributors to create and share their own extensions.</p><p>The extension mechanism will need a standard form by 1.0. For 0.80, we should have our best guess at a complete solution that meets the design goals.</p>`,58);function x(y,w){const i=n("ExternalLinkIcon");return s(),l("div",null,[d,e("ol",null,[e("li",null,[e("p",null,[a('There should be one -- and preferably only one -- obvious way to do it. You will probably recognize this from the "'),e("a",u,[a("Zen of Python"),r(i)]),a('"!')])]),c,p,m,g,f]),b])}const _=o(h,[["render",x],["__file","philosophy_0_80.html.vue"]]);export{_ as default};
