import{_ as p,M as c,p as i,q as d,Q as a,t as s,N as n,U as t,a1 as o}from"./framework-344bb0e4.js";const r={},u=a("h1",{id:"types-of-data",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#types-of-data","aria-hidden":"true"},"#"),s(" Types of Data")],-1),h=a("p",null,"Traditionally, Unix shell commands have communicated with each other using strings of text: one command would write text to standard output (often abbreviated 'stdout') and the other would read text from standard input (or 'stdin'), allowing the two commands to communicate.",-1),m=a("p",null,"Nu embraces this approach, and expands it to include other types of data, in addition to strings.",-1),b=a("p",null,"Like many programming languages, Nu models data using a set of simple, and structured data types. Simple data types include integers, floats, strings, booleans, dates. There are also special types for filesizes and time durations.",-1),k=a("code",null,"describe",-1),g=o('<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token number">42</span> <span class="token operator">|</span> describe\n</code></pre></div><h2 id="types-at-a-glance" tabindex="-1"><a class="header-anchor" href="#types-at-a-glance" aria-hidden="true">#</a> Types at a glance</h2><table><thead><tr><th>Type</th><th>Example</th></tr></thead><tbody><tr><td>Integers</td><td><code>-65535</code></td></tr><tr><td>Decimals (floats)</td><td><code>9.9999</code>, <code>Infinity</code></td></tr><tr><td>Strings</td><td><code>&quot;hole 18&quot;, &#39;hole 18&#39;, `hole 18`, hole18</code></td></tr><tr><td>Booleans</td><td><code>true</code></td></tr><tr><td>Dates</td><td><code>2000-01-01</code></td></tr><tr><td>Durations</td><td><code>2min + 12sec</code></td></tr><tr><td>File sizes</td><td><code>64mb</code></td></tr><tr><td>Ranges</td><td><code>0..4</code>, <code>0..&lt;5</code>, <code>0..</code>, <code>..4</code></td></tr><tr><td>Binary</td><td><code>0x[FE FF]</code></td></tr><tr><td>Lists</td><td><code>[0 1 &#39;two&#39; 3]</code></td></tr><tr><td>Records</td><td><code>{name:&quot;Nushell&quot;, lang: &quot;Rust&quot;}</code></td></tr><tr><td>Tables</td><td><code>[{x:12, y:15}, {x:8, y:9}]</code>, <code>[[x, y]; [12, 15], [8, 9]]</code></td></tr><tr><td>Closures</td><td><code>{|e| $e + 1 | into string }</code>, <code>{ $in.name.0 | path exists }</code></td></tr><tr><td>Blocks</td><td><code>if true { print &quot;hello!&quot; }</code>, <code>loop { print &quot;press ctrl-c to exit&quot; }</code></td></tr><tr><td>Null</td><td><code>null</code></td></tr></tbody></table><h2 id="integers" tabindex="-1"><a class="header-anchor" href="#integers" aria-hidden="true">#</a> Integers</h2>',4),f=a("code",null,"into int",-1),y=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token string">&quot;-5&quot;</span> <span class="token operator">|</span> into int
</code></pre></div><h2 id="decimals" tabindex="-1"><a class="header-anchor" href="#decimals" aria-hidden="true">#</a> Decimals</h2>`,2),_=a("code",null,"into decimal",-1),v=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token string">&quot;1.2&quot;</span> <span class="token operator">|</span> into decimal
</code></pre></div><h2 id="strings" tabindex="-1"><a class="header-anchor" href="#strings" aria-hidden="true">#</a> Strings</h2><p>A string of characters that represents text. There are a few ways these can be constructed:</p><ul><li>Double quotes <ul><li><code>&quot;Line1\\nLine2\\n&quot;</code></li></ul></li><li>Single quotes <code>&#39;She said &quot;Nushell is the future&quot;.&#39;</code></li><li>Dynamic string interpolation <ul><li><code>$&quot;6 x 7 = (6 * 7)&quot;</code></li><li><code>ls | each { |it| $&quot;($it.name) is ($it.size)&quot; }</code></li></ul></li><li>Bare strings <ul><li><code>print hello</code></li><li><code>[foo bar baz]</code></li></ul></li></ul>`,4),x={href:"https://www.nushell.sh/book/loading_data.html#handling-strings",target:"_blank",rel:"noopener noreferrer"},w=o(`<h2 id="booleans" tabindex="-1"><a class="header-anchor" href="#booleans" aria-hidden="true">#</a> Booleans</h2><p>There are just two boolean values: <code>true</code> and <code>false</code>. Rather than writing the values directly, they often result from a comparison:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> mybool <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">1</span>
<span class="token operator">&gt;</span> <span class="token variable">$mybool</span>
<span class="token boolean">true</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> mybool <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$env</span><span class="token builtin class-name">.</span><span class="token environment constant">HOME</span> <span class="token operator">|</span> path exists<span class="token punctuation">)</span>
<span class="token operator">&gt;</span> <span class="token variable">$mybool</span>
<span class="token boolean">true</span>
</code></pre></div><h2 id="dates" tabindex="-1"><a class="header-anchor" href="#dates" aria-hidden="true">#</a> Dates</h2><p>Dates and times are held together in the Date value type. Date values used by the system are timezone-aware, and by default use the UTC timezone.</p><p>Dates are in three forms, based on the RFC 3339 standard:</p><ul><li>A date: <ul><li><code>2022-02-02</code></li></ul></li><li>A date and time (in GMT): <ul><li><code>2022-02-02T14:30:00</code></li></ul></li><li>A date and time with timezone: <ul><li><code>2022-02-02T14:30:00+05:00</code></li></ul></li></ul><h2 id="durations" tabindex="-1"><a class="header-anchor" href="#durations" aria-hidden="true">#</a> Durations</h2><p>Durations represent a length of time. This chart shows all durations currently supported:</p><table><thead><tr><th>Duration</th><th>Length</th></tr></thead><tbody><tr><td><code>1ns</code></td><td>one nanosecond</td></tr><tr><td><code>1us</code></td><td>one microsecond</td></tr><tr><td><code>1ms</code></td><td>one millisecond</td></tr><tr><td><code>1sec</code></td><td>one second</td></tr><tr><td><code>1min</code></td><td>one minute</td></tr><tr><td><code>1hr</code></td><td>one hour</td></tr><tr><td><code>1day</code></td><td>one day</td></tr><tr><td><code>1wk</code></td><td>one week</td></tr></tbody></table><p>You can make fractional durations:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token number">3</span>.14day
3day 3hr 21min
</code></pre></div><p>And you can do calculations with durations:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> 30day / 1sec  <span class="token comment"># How many seconds in 30 days?</span>
<span class="token number">2592000</span>
</code></pre></div><h2 id="file-sizes" tabindex="-1"><a class="header-anchor" href="#file-sizes" aria-hidden="true">#</a> File sizes</h2><p>Nushell also has a special type for file sizes. Examples include <code>100b</code>, <code>15kb</code>, and <code>100mb</code>.</p><p>The full list of filesize units are:</p><ul><li><code>b</code>: bytes</li><li><code>kb</code>: kilobytes (aka 1000 bytes)</li><li><code>mb</code>: megabytes</li><li><code>gb</code>: gigabytes</li><li><code>tb</code>: terabytes</li><li><code>pb</code>: petabytes</li><li><code>eb</code>: exabytes</li><li><code>zb</code>: zettabyte</li><li><code>kib</code>: kibibytes (aka 1024 bytes)</li><li><code>mib</code>: mebibytes</li><li><code>gib</code>: gibibytes</li><li><code>tib</code>: tebibytes</li><li><code>pib</code>: pebibytes</li><li><code>eib</code>: exbibyte</li><li><code>zib</code>: zebibyte</li></ul><p>As with durations, you can make fractional file sizes, and do calculations:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> 1Gb / 1b
<span class="token number">1000000000</span>
<span class="token operator">&gt;</span> 1Gib / 1b
<span class="token number">1073741824</span>
<span class="token operator">&gt;</span> <span class="token punctuation">(</span>1Gib / 1b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> ** <span class="token number">30</span>
<span class="token boolean">true</span>
</code></pre></div><h2 id="ranges" tabindex="-1"><a class="header-anchor" href="#ranges" aria-hidden="true">#</a> Ranges</h2><p>A range is a way of expressing a sequence of values from start to finish. They take the form &lt;start&gt;..&lt;end&gt;. For example, the range <code>1..3</code> means the numbers 1, 2, and 3.</p><h3 id="inclusive-and-non-inclusive-ranges" tabindex="-1"><a class="header-anchor" href="#inclusive-and-non-inclusive-ranges" aria-hidden="true">#</a> Inclusive and non-inclusive ranges</h3><p>Ranges are inclusive by default, meaning that the ending value is counted as part of the range. The range <code>1..3</code> includes the number <code>3</code> as the last value in the range.</p><p>Sometimes, you may want a range that is limited by a number but doesn&#39;t use that number in the output. For this, you can use <code>..&lt;</code> instead of <code>..</code>. For example, <code>1..&lt;5</code> is the numbers 1, 2, 3, and 4.</p><h3 id="open-ended-ranges" tabindex="-1"><a class="header-anchor" href="#open-ended-ranges" aria-hidden="true">#</a> Open-ended ranges</h3><p>Ranges can also be open-ended. You can remove the start or the end of the range to make it open-ended.</p>`,27),q=a("code",null,"3..",-1),T=a("code",null,"take",-1),z=o(`<p>You can also make the start of the range open. In this case, Nushell will start counting with <code>0</code>. For example, the range <code>..2</code> is the numbers 0, 1, and 2.</p><h2 id="binary-data" tabindex="-1"><a class="header-anchor" href="#binary-data" aria-hidden="true">#</a> Binary data</h2><p>Binary data, like the data from an image file, is a group of raw bytes.</p><p>You can write binary as a literal using any of the <code>0x[...]</code>, <code>0b[...]</code>, or <code>0o[...]</code> forms:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> 0x<span class="token punctuation">[</span>1F FF<span class="token punctuation">]</span>  <span class="token comment"># Hexadecimal</span>
<span class="token operator">&gt;</span> 0b<span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1010</span><span class="token punctuation">]</span> <span class="token comment"># Binary</span>
<span class="token operator">&gt;</span> 0o<span class="token punctuation">[</span><span class="token number">377</span><span class="token punctuation">]</span>    <span class="token comment"># Octal</span>
</code></pre></div><p>Incomplete bytes will be left-padded with zeros.</p><h2 id="structured-data" tabindex="-1"><a class="header-anchor" href="#structured-data" aria-hidden="true">#</a> Structured data</h2><p>Structured data builds from the simple data. For example, instead of a single integer, structured data gives us a way to represent multiple integers in the same value. Here&#39;s a list of the currently supported structured data types: records, lists and tables.</p><h2 id="records" tabindex="-1"><a class="header-anchor" href="#records" aria-hidden="true">#</a> Records</h2><p>Records hold key-value pairs, which associate string keys with various data values. Record syntax is very similar to objects in JSON. However, commas are <em>not</em> required to separate values if Nushell can easily distinguish them!</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">{</span>name: sam rank: <span class="token number">10</span><span class="token punctuation">}</span>
╭──────┬─────╮
│ name │ sam │
│ rank │ <span class="token number">10</span>  │
╰──────┴─────╯
</code></pre></div><p>As these can sometimes have many fields, a record is printed up-down rather than left-right.</p>`,12),N={class:"custom-container tip"},$=a("p",{class:"custom-container-title"},"TIP",-1),F=a("p",null,'A record is identical to a single row of a table (see below). You can think of a record as essentially being a "one-row table", with each of its keys as a column (although a true one-row table is something distinct from a record).',-1),D=a("em",null,"also",-1),S=a("code",null,"insert",-1),A=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">{</span>x:3 y:1<span class="token punctuation">}</span> <span class="token operator">|</span> insert z <span class="token number">0</span>
╭───┬───╮
│ x │ <span class="token number">3</span> │
│ y │ <span class="token number">1</span> │
│ z │ <span class="token number">0</span> │
╰───┴───╯
</code></pre></div>`,1),R=o(`<p>You can iterate over records by first transposing it into a table:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">{</span>name: sam, rank: <span class="token number">10</span><span class="token punctuation">}</span> <span class="token operator">|</span> transpose key value
╭───┬──────┬───────╮
│ <span class="token comment"># │ key  │ value │</span>
├───┼──────┼───────┤
│ <span class="token number">0</span> │ name │  sam  │
│ <span class="token number">1</span> │ rank │   <span class="token number">10</span>  │
╰───┴──────┴───────╯
</code></pre></div><p>Accessing records&#39; data is done by placing a <code>.</code> before a string, which is usually a bare string:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">{</span>x:12 y:4<span class="token punctuation">}</span>.x
<span class="token number">12</span>
</code></pre></div><p>However, if a record has a key name that can&#39;t be expressed as a bare string, or resembles an integer (see lists, below), you&#39;ll need to use more explicit string syntax, like so:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token string">&quot;1&quot;</span>:true <span class="token string">&quot; &quot;</span>:false<span class="token punctuation">}</span>.<span class="token string">&quot; &quot;</span>
<span class="token boolean">false</span>
</code></pre></div><h2 id="lists" tabindex="-1"><a class="header-anchor" href="#lists" aria-hidden="true">#</a> Lists</h2><p>Lists are ordered sequences of data values. List syntax is very similar to arrays in JSON. However, commas are <em>not</em> required to separate values if Nushell can easily distinguish them!</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span>sam fred george<span class="token punctuation">]</span>
╭───┬────────╮
│ <span class="token number">0</span> │ sam    │
│ <span class="token number">1</span> │ fred   │
│ <span class="token number">2</span> │ george │
╰───┴────────╯
</code></pre></div>`,9),Y={class:"custom-container tip"},B=a("p",{class:"custom-container-title"},"TIP",-1),I=a("em",null,"also",-1),L=a("code",null,"where",-1),C=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span>bell book candle<span class="token punctuation">]</span> <span class="token operator">|</span> where <span class="token punctuation">(</span><span class="token variable">$it</span> <span class="token operator">=~</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>
╭───┬──────╮
│ <span class="token number">0</span> │ bell │
│ <span class="token number">1</span> │ book │
╰───┴──────╯
</code></pre></div>`,1),V=o(`<p>Accessing lists&#39; data is done by placing a <code>.</code> before a bare integer:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span>a b c<span class="token punctuation">]</span>.1
b
</code></pre></div>`,2),H=a("code",null,"range",-1),E=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span>a b c d e f<span class="token punctuation">]</span> <span class="token operator">|</span> range <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span>
╭───┬───╮
│ <span class="token number">0</span> │ b │
│ <span class="token number">1</span> │ c │
│ <span class="token number">2</span> │ d │
╰───┴───╯
</code></pre></div><h2 id="tables" tabindex="-1"><a class="header-anchor" href="#tables" aria-hidden="true">#</a> Tables</h2><p>The table is a core data structure in Nushell. As you run commands, you&#39;ll see that many of them return tables as output. A table has both rows and columns.</p><p>We can create our own tables similarly to how we create a list. Because tables also contain columns and not just values, we pass in the name of the column values:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>column1, column2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>Value1, Value2<span class="token punctuation">]</span> <span class="token punctuation">[</span>Value3, Value4<span class="token punctuation">]</span><span class="token punctuation">]</span>
╭───┬─────────┬─────────╮
│ <span class="token comment"># │ column1 │ column2 │</span>
├───┼─────────┼─────────┤
│ <span class="token number">0</span> │ Value1  │ Value2  │
│ <span class="token number">1</span> │ Value3  │ Value4  │
╰───┴─────────┴─────────╯
</code></pre></div><p>You can also create a table as a list of records, JSON-style:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>name: sam, rank: <span class="token number">10</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span>name: bob, rank: <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
╭───┬──────┬──────╮
│ <span class="token comment"># │ name │ rank │</span>
├───┼──────┼──────┤
│ <span class="token number">0</span> │ sam  │   <span class="token number">10</span> │
│ <span class="token number">1</span> │ bob  │    <span class="token number">7</span> │
╰───┴──────┴──────╯
</code></pre></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Internally, tables are simply <strong>lists of records</strong>. This means that any command which extracts or isolates a specific row of a table will produce a record. For example, <code>get 0</code>, when used on a list, extracts the first value. But when used on a table (a list of records), it extracts a record:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>x:12, y:5<span class="token punctuation">}</span>, <span class="token punctuation">{</span>x:3, y:6<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">|</span> get <span class="token number">0</span>
╭───┬────╮
│ x │ <span class="token number">12</span> │
│ y │ <span class="token number">5</span>  │
╰───┴────╯
</code></pre></div><p>This is true regardless of which table syntax you use:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span><span class="token punctuation">[</span>x,y<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">12,5</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">3,6</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">|</span> get <span class="token number">0</span>
╭───┬────╮
│ x │ <span class="token number">12</span> │
│ y │ <span class="token number">5</span>  │
╰───┴────╯
</code></pre></div></div><h3 id="cell-paths" tabindex="-1"><a class="header-anchor" href="#cell-paths" aria-hidden="true">#</a> Cell Paths</h3><p>You can combine list and record data access syntax to navigate tables. When used on tables, these access chains are called &quot;cell paths&quot;.</p><p>You can access individual rows by number to obtain records:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>langs:<span class="token punctuation">[</span>Rust JS Python<span class="token punctuation">]</span>, releases:60<span class="token punctuation">}</span><span class="token punctuation">]</span>.0
╭──────────┬────────────────╮
│ langs    │ <span class="token punctuation">[</span>list <span class="token number">3</span> items<span class="token punctuation">]</span> │
│ releases │ <span class="token number">60</span>             │
╰──────────┴────────────────╯
<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>langs:<span class="token punctuation">[</span>Rust JS Python<span class="token punctuation">]</span>, releases:60<span class="token punctuation">}</span><span class="token punctuation">]</span>.0.langs.2
Python
</code></pre></div><p>Moreover, you can also access entire columns of a table by name, to obtain lists:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>x:12 y:5<span class="token punctuation">}</span> <span class="token punctuation">{</span>x:4 y:7<span class="token punctuation">}</span> <span class="token punctuation">{</span>x:2 y:2<span class="token punctuation">}</span><span class="token punctuation">]</span>.x
╭───┬────╮
│ <span class="token number">0</span> │ <span class="token number">12</span> │
│ <span class="token number">1</span> │  <span class="token number">4</span> │
│ <span class="token number">2</span> │  <span class="token number">2</span> │
╰───┴────╯
</code></pre></div>`,14),O=a("code",null,"select",-1),J=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>x:0 y:5 z:1<span class="token punctuation">}</span> <span class="token punctuation">{</span>x:4 y:7 z:3<span class="token punctuation">}</span> <span class="token punctuation">{</span>x:2 y:2 z:0<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">select</span> y z
╭───┬───┬───╮
│ <span class="token comment"># │ y │ z │</span>
├───┼───┼───┤
│ <span class="token number">0</span> │ <span class="token number">5</span> │ <span class="token number">1</span> │
│ <span class="token number">1</span> │ <span class="token number">7</span> │ <span class="token number">3</span> │
│ <span class="token number">2</span> │ <span class="token number">2</span> │ <span class="token number">0</span> │
╰───┴───┴───╯
</code></pre></div>`,1),P=a("code",null,"select",-1),W=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>x:0 y:5 z:1<span class="token punctuation">}</span> <span class="token punctuation">{</span>x:4 y:7 z:3<span class="token punctuation">}</span> <span class="token punctuation">{</span>x:2 y:2 z:0<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">select</span> <span class="token number">1</span> <span class="token number">2</span>
╭───┬───┬───┬───╮
│ <span class="token comment"># │ x │ y │ z │</span>
├───┼───┼───┼───┤
│ <span class="token number">0</span> │ <span class="token number">4</span> │ <span class="token number">7</span> │ <span class="token number">3</span> │
│ <span class="token number">1</span> │ <span class="token number">2</span> │ <span class="token number">2</span> │ <span class="token number">0</span> │
╰───┴───┴───┴───╯
</code></pre></div><p>There are numerous other commands for selecting and reducing the data in tables, records and lists.</p><h2 id="closures" tabindex="-1"><a class="header-anchor" href="#closures" aria-hidden="true">#</a> Closures</h2><p>Closures are anonymous functions that can be passed a value through parameters and <em>close over</em> (i.e. use) a variable outside their scope.</p><p>For example, in the command <code>each { |it| print $it }</code> the closure is the portion contained in curly braces, <code>{ |it| print $it }</code>. Closure parameters are specified between a pair of pipe symbols (for example, <code>|it|</code>) if necessary. You can also use a pipeline input as <code>$in</code> in most closures instead of providing an explicit parameter: <code>each { print $in }</code></p>`,5),G=a("code",null,"do",-1),j=a("div",{class:"language-nu","data-ext":"nu"},[a("pre",{class:"language-nu"},[a("code",null,`# Assign a closure to a variable
let greet = { |name| print $"Hello ($name)"}
do $greet "Julian"
`)])],-1),M=a("code",null,"$it",-1),U=a("code",null,"each",-1),Q=a("code",null,"each { |x| print $x }",-1),K=a("code",null,"each { |it| print $it }",-1),X=a("h2",{id:"blocks",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#blocks","aria-hidden":"true"},"#"),s(" Blocks")],-1),Z=a("code",null,"if",-1),aa=a("div",{class:"language-nu","data-ext":"nu"},[a("pre",{class:"language-nu"},[a("code",null,`mut x = 1
if true {
    $x += 1000
}
print $x
`)])],-1),sa=a("h2",{id:"null",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#null","aria-hidden":"true"},"#"),s(" Null")],-1),na=a("code",null,"null",-1),ea=a("code",null,"$nothing",-1),ta=a("code",null,"null",-1),oa=a("code",null,"save",-1),ca=a("code",null,"cd",-1),la=a("code",null,"null",-1),pa=o(`<p>You can place <code>null</code> at the end of a pipeline to replace the pipeline&#39;s output with it, and thus print nothing:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout featurebranch <span class="token operator">|</span> null
</code></pre></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p><code>null</code> is not the same as the absence of a value! It is possible for a table to be produced that has holes in some of its rows. Attempting to access this value will not produce <code>null</code>, but instead cause an error:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>a:1 b:2<span class="token punctuation">}</span> <span class="token punctuation">{</span>b:1<span class="token punctuation">}</span><span class="token punctuation">]</span>
╭───┬────┬───╮
│ <span class="token comment"># │ a  │ b │</span>
├───┼────┼───┤
│ <span class="token number">0</span> │  <span class="token number">1</span> │ <span class="token number">2</span> │
│ <span class="token number">1</span> │ ❎ │ <span class="token number">1</span> │
╰───┴────┴───╯
<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>a:1 b:2<span class="token punctuation">}</span> <span class="token punctuation">{</span>b:1<span class="token punctuation">}</span><span class="token punctuation">]</span>.1.a
Error: nu::shell::column_not_found

  × Cannot <span class="token function">find</span> <span class="token function">column</span>
   ╭─<span class="token punctuation">[</span>entry <span class="token comment">#15:1:1]</span>
 <span class="token number">1</span> │ <span class="token punctuation">[</span><span class="token punctuation">{</span>a:1 b:2<span class="token punctuation">}</span> <span class="token punctuation">{</span>b:1<span class="token punctuation">}</span><span class="token punctuation">]</span>.1.a
   ·            ──┬──    ┬
   ·              │      ╰── cannot <span class="token function">find</span> <span class="token function">column</span>
   ·              ╰── value originates here
   ╰────
</code></pre></div><p>The absence of a value is (as of Nushell 0.71) printed as the ❎ emoji in interactive output.</p></div>`,3);function ia(da,ra){const e=c("RouterLink"),l=c("ExternalLinkIcon");return i(),d("div",null,[u,h,m,b,a("p",null,[s("The "),n(e,{to:"/commands/docs/describe.html"},{default:t(()=>[k]),_:1}),s(" command returns the type of a data value:")]),g,a("p",null,[s('Examples of integers (i.e. "round numbers") include 1, 0, -5, and 100. You can parse a string into an integer with the '),n(e,{to:"/commands/docs/into_int.html"},{default:t(()=>[f]),_:1}),s(" command")]),y,a("p",null,[s("Decimal numbers are numbers with some fractional component. Examples include 1.5, 2.0, and 15.333. You can cast a string into an Decimal with the "),n(e,{to:"/commands/docs/into_decimal.html"},{default:t(()=>[_]),_:1}),s(" command")]),v,a("p",null,[s("See "),n(e,{to:"/book/working_with_strings.html"},{default:t(()=>[s("Working with strings")]),_:1}),s(" and "),a("a",x,[s("Handling Strings"),n(l)]),s(" for details.")]),w,a("p",null,[s("Let's say you wanted to start counting at 3, but you didn't have a specific end in mind. You could use the range "),q,s(" to represent this. When you use a range that's open-ended on the right side, remember that this will continue counting for as long as possible, which could be a very long time! You'll often want to use open-ended ranges with commands like "),n(e,{to:"/commands/docs/take.html"},{default:t(()=>[T]),_:1}),s(", so you can take the number of elements you want from the range.")]),z,a("div",N,[$,F,a("p",null,[s("This means that any command that operates on a table's rows "),D,s(" operates on records. For instance, "),n(e,{to:"/commands/docs/insert.html"},{default:t(()=>[S]),_:1}),s(", which adds data to each of a table's rows, can be used with records:")]),A]),R,a("div",Y,[B,a("p",null,[s('Lists are equivalent to the individual columns of tables. You can think of a list as essentially being a "one-column table" (with no column name). Thus, any command which operates on a column '),I,s(" operates on a list. For instance, "),n(e,{to:"/commands/docs/where.html"},{default:t(()=>[L]),_:1}),s(" can be used with lists:")]),C]),V,a("p",null,[s("To get a sub-list from a list, you can use the "),n(e,{to:"/commands/docs/range.html"},{default:t(()=>[H]),_:1}),s(" command:")]),E,a("p",null,[s("Of course, these resulting lists don't have the column names of the table. To remove columns from a table while leaving it as a table, you'll commonly use the "),n(e,{to:"/commands/docs/select.html"},{default:t(()=>[O]),_:1}),s(" command with column names:")]),J,a("p",null,[s("To remove rows from a table, you'll commonly use the "),n(e,{to:"/commands/docs/select.html"},{default:t(()=>[P]),_:1}),s(" command with row numbers, as you would with a list:")]),W,a("p",null,[s("Closures itself can be bound to a named variable and passed as a parameter. To call a closure directly in your code use the "),n(e,{to:"/commands/docs/do.html"},{default:t(()=>[G]),_:1}),s(" command.")]),j,a("p",null,[s("Closures are a useful way to represent code that can be executed on each row of data. It is idiomatic to use "),M,s(" as a parameter name in "),n(e,{to:"/commands/docs/each.html"},{default:t(()=>[U]),_:1}),s(" blocks, but not required; "),Q,s(" works the same way as "),K,s(".")]),X,a("p",null,[s("Blocks don't close over variables, don't have parameters, and can't be passed as a value. However, unlike closures, blocks can access mutable variable in the parent closure. For example, mutating a variable inside the block used in an "),n(e,{to:"/commands/docs/if.html"},{default:t(()=>[Z]),_:1}),s(" call is valid:")]),aa,sa,a("p",null,[s("Finally, there is "),na,s(" (also known as "),ea,s(`) which is the language's "nothing" value, similar to JSON's "null". Whenever Nushell would print the `),ta,s(" value (outside of a string or data structure), it prints nothing instead. Hence, most of Nushell's file system commands (like "),n(e,{to:"/commands/docs/save.html"},{default:t(()=>[oa]),_:1}),s(" or "),n(e,{to:"/commands/docs/cd.html"},{default:t(()=>[ca]),_:1}),s(") produce "),la,s(".")]),pa])}const ha=p(r,[["render",ia],["__file","types_of_data.html.vue"]]);export{ha as default};
