import{_ as d,M as i,p as r,q as c,Q as e,t,N as n,U as o,a1 as s}from"./framework-344bb0e4.js";const u={},h=s(`<h1 id="pipelines" tabindex="-1"><a class="header-anchor" href="#pipelines" aria-hidden="true">#</a> Pipelines</h1><p>One of the core designs of Nu is the pipeline, a design idea that traces its roots back decades to some of the original philosophy behind Unix. Just as Nu extends from the single string data type of Unix, Nu also extends the idea of the pipeline to include more than just text.</p><h2 id="basics" tabindex="-1"><a class="header-anchor" href="#basics" aria-hidden="true">#</a> Basics</h2><p>A pipeline is composed of three parts: the input, the filter, and the output.</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; open &quot;Cargo.toml&quot; | inc package.version --minor | save &quot;Cargo_new.toml&quot;
</code></pre></div>`,5),m=e("code",null,'open "Cargo.toml"',-1),p=e("code",null,"ls",-1),_=e("code",null,"inc package.version --minor",-1),g=e("code",null,"inc",-1),x=s(`<p>The last command, <code>save &quot;Cargo_new.toml&quot;</code>, is an output (sometimes called a &quot;sink&quot;). An output takes input from the pipeline and does some final operation on it. In our example, we save what comes through the pipeline to a file as the final step. Other types of output commands may take the values and view them for the user.</p><p>The <code>$in</code> variable will collect the pipeline into a value for you, allowing you to access the whole stream as a parameter:</p><div class="language-nushell" data-ext="nushell"><pre class="language-nushell"><code>&gt; [1 2 3] | $in.1 * $in.2
6
</code></pre></div><h2 id="multi-line-pipelines" tabindex="-1"><a class="header-anchor" href="#multi-line-pipelines" aria-hidden="true">#</a> Multi-line pipelines</h2><p>If a pipeline is getting a bit long for one line, you can enclose it within <code>(</code> and <code>)</code> to create a subexpression:</p><div class="language-nushell" data-ext="nushell"><pre class="language-nushell"><code>(
    &quot;01/22/2021&quot; |
    parse &quot;{month}/{day}/{year}&quot; |
    get year
)
</code></pre></div>`,6),f={href:"https://www.nushell.sh/book/variables_and_subexpressions.html#subexpressions",target:"_blank",rel:"noopener noreferrer"},w=s(`<h2 id="semicolons" tabindex="-1"><a class="header-anchor" href="#semicolons" aria-hidden="true">#</a> Semicolons</h2><p>Take this example:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; line1; line2 | line3
</code></pre></div><p>Here, semicolons are used in conjunction with pipelines. When a semicolon is used, no output data is produced to be piped. As such, the <code>$in</code> variable will not work when used immediately after the semicolon.</p><ul><li>As there is a semicolon after <code>line1</code>, the command will run to completion and get displayed on the screen.</li><li><code>line2</code> | <code>line3</code> is a normal pipeline. It runs, and its contents are displayed after <code>line1</code>&#39;s contents.</li></ul><h2 id="working-with-external-commands" tabindex="-1"><a class="header-anchor" href="#working-with-external-commands" aria-hidden="true">#</a> Working with external commands</h2>`,6),v=e("p",null,[e("code",null,"internal_command | external_command")],-1),b=e("p",null,[t("Data will flow from the internal_command to the external_command. This data will get converted to a string, so that they can be sent to the "),e("code",null,"stdin"),t(" of the external_command.")],-1),y=e("p",null,[e("code",null,"external_command | internal_command")],-1),k=e("code",null,"lines",-1),N=e("p",null,[e("code",null,"external_command_1 | external_command_2")],-1),q=e("p",null,[t("Nu works with data piped between two external commands in the same way as other shells, like Bash would. The "),e("code",null,"stdout"),t(" of external_command_1 is connected to the "),e("code",null,"stdin"),t(" of external_command_2. This lets data flow naturally between the two commands.")],-1),T=e("h2",{id:"behind-the-scenes",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#behind-the-scenes","aria-hidden":"true"},"#"),t(" Behind the scenes")],-1),I=e("code",null,"ls",-1),$=e("code",null,"table",-1),B=e("code",null,"table",-1),A=s(`<p>In effect, the command:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; ls
</code></pre></div><p>And the pipeline:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; ls | table
</code></pre></div><p>Are one and the same.</p><h2 id="output-result-to-external-commands" tabindex="-1"><a class="header-anchor" href="#output-result-to-external-commands" aria-hidden="true">#</a> Output result to external commands</h2><p>Sometimes you want to output Nushell structured data to an external command for further processing. However, Nushell&#39;s default formatting options for structured data may not be what you want. For example, you want to find a file named &quot;tutor&quot; under &quot;/usr/share/vim/runtime&quot; and check its ownership</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; ls /usr/share/nvim/runtime/
╭────┬───────────────────────────────────────┬──────┬─────────┬───────────────╮
│  # │                 name                  │ type │  size   │   modified    │
├────┼───────────────────────────────────────┼──────┼─────────┼───────────────┤
│  0 │ /usr/share/nvim/runtime/autoload      │ dir  │  4.1 KB │ 2 days ago    │
..........
..........
..........

│ 31 │ /usr/share/nvim/runtime/tools         │ dir  │  4.1 KB │ 2 days ago    │
│ 32 │ /usr/share/nvim/runtime/tutor         │ dir  │  4.1 KB │ 2 days ago    │
├────┼───────────────────────────────────────┼──────┼─────────┼───────────────┤
│  # │                 name                  │ type │  size   │   modified    │
╰────┴───────────────────────────────────────┴──────┴─────────┴───────────────╯
</code></pre></div>`,8),C=e("code",null,"grep",-1),L={href:"https://www.nushell.sh/book/pipelines.html",target:"_blank",rel:"noopener noreferrer"},j=e("code",null,"^ls",-1),F=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls /usr/share/nvim/runtime/ | get name | ^grep tutor | ^ls -la $in
ls: cannot access ''$'\\342\\224\\202'' 32 '$'\\342\\224\\202'' /usr/share/nvim/runtime/tutor        '$'\\342\\224\\202\\n': No such file or directory
`)])],-1),S=e("code",null,"╭",-1),U=e("code",null,"─",-1),V=e("code",null,"┬",-1),E=e("code",null,"╮",-1),K=e("code",null,"to text",-1),O=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls /usr/share/nvim/runtime/ | get name | to text | ^grep tutor | tr -d '\\n' | ^ls -la $in
total 24
drwxr-xr-x@  5 pengs  admin   160 14 Nov 13:12 .
drwxr-xr-x@  4 pengs  admin   128 14 Nov 13:42 en
-rw-r--r--@  1 pengs  admin  5514 14 Nov 13:42 tutor.tutor
-rw-r--r--@  1 pengs  admin  1191 14 Nov 13:42 tutor.tutor.json
`)])],-1),W=e("code",null,"find",-1),z=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls /usr/share/nvim/runtime/ | get name | find tutor | ^ls -al $in
`)])],-1);function D(H,M){const a=i("RouterLink"),l=i("ExternalLinkIcon");return r(),c("div",null,[h,e("p",null,[t("The first command, "),m,t(`, is an input (sometimes also called a "source" or "producer"). This creates or loads data and feeds it into a pipeline. It's from input that pipelines have values to work with. Commands like `),n(a,{to:"/commands/docs/ls.html"},{default:o(()=>[p]),_:1}),t(" are also inputs, as they take data from the filesystem and send it through the pipelines so that it can be used.")]),e("p",null,[t("The second command, "),_,t(", is a filter. Filters take the data they are given and often do something with it. They may change it (as with the "),n(a,{to:"/commands/docs/inc.html"},{default:o(()=>[g]),_:1}),t(" command in our example), or they may do another operation, like logging, as the values pass through.")]),x,e("p",null,[t("Also see "),e("a",f,[t("Subexpressions"),n(l)])]),w,e("p",null,[t("Nu commands communicate with each other using the Nu data types (see "),n(a,{to:"/book/types_of_data.html"},{default:o(()=>[t("types of data")]),_:1}),t("), but what about commands outside of Nu? Let's look at some examples of working with external commands:")]),v,b,y,e("p",null,[t("Data coming from an external command into Nu will come in as bytes that Nushell will try to automatically convert to UTF-8 text. If successful, a stream of text data will be sent to internal_command. If unsuccessful, a stream of binary data will be sent to internal command. Commands like "),n(a,{to:"/commands/docs/lines.html"},{default:o(()=>[k]),_:1}),t(" help make it easier to bring in data from external commands, as it gives discrete lines of data to work with.")]),N,q,T,e("p",null,[t("You may have wondered how we see a table if "),n(a,{to:"/commands/docs/ls.html"},{default:o(()=>[I]),_:1}),t(" is an input and not an output. Nu adds this output for us automatically using another command called "),n(a,{to:"/commands/docs/table.html"},{default:o(()=>[$]),_:1}),t(". The "),n(a,{to:"/commands/docs/table.html"},{default:o(()=>[B]),_:1}),t(" command is appended to any pipeline that doesn't have an output. This allows us to see the result.")]),A,e("p",null,[t("You decided to use "),C,t(" and "),e("a",L,[t("pipe"),n(l)]),t(" the result to external "),j]),F,e("p",null,[t("What's wrong? Nushell renders lists and tables (by adding a border with characters like "),S,t(","),U,t(","),V,t(","),E,t(") before piping them as text to external commands. If that's not the behavior you want, you must explicitly convert the data to a string before piping it to an external. For example, you can do so with "),n(a,{to:"/commands/docs/to_text.html"},{default:o(()=>[K]),_:1}),t(":")]),O,e("p",null,[t("(Actually, for this simple usage you can just use "),n(a,{to:"/commands/docs/find.html"},{default:o(()=>[W]),_:1}),t(")")]),z])}const Y=d(u,[["render",D],["__file","pipelines.html.vue"]]);export{Y as default};
