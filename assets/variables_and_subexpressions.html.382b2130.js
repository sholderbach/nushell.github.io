import{_ as p,z as l,A as c,X as s,C as a,T as o,$ as t,a6 as n,Q as r}from"./framework.3d018c9f.js";const i={},d=n(`<h1 id="变量和子表达式" tabindex="-1"><a class="header-anchor" href="#变量和子表达式" aria-hidden="true">#</a> 变量和子表达式</h1><p>在 Nushell 中有两种类型的求值表达式：变量和子表达式。如果你看到一个以美元符号（<code>$</code>）开头的字符串的话，你就应该知道你看到的是一个求值表达式。这表明当 Nushell 运行到此处时需要执行一个求值操作来处理这个表达式并使用此结果值。这两种求值表达式都支持一个简单形式和一个&quot;路径&quot;形式，用于处理更复杂的数据。</p><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h2><p>在两种求值表达式中比较简单的是变量。在求值过程中，变量被其值所取代。</p><p>如果我们创建了一个变量，我们可以通过使用<code>$</code>来引用它并打印其内容：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> my_value <span class="token operator">=</span> <span class="token number">4</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$my_value</span>
<span class="token number">4</span>
</code></pre></div><p>Nushell 中的变量是不可变的，这意味着你不能在声明后修改它的值。 不过它们可以在嵌套块中被隐藏，这导致：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> my_value <span class="token operator">=</span> <span class="token number">4</span>
<span class="token operator">&gt;</span> <span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token builtin class-name">let</span> my_value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$my_value</span> <span class="token punctuation">}</span>
<span class="token number">5</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$my_value</span>
<span class="token number">4</span>
</code></pre></div><h2 id="变量路径" tabindex="-1"><a class="header-anchor" href="#变量路径" aria-hidden="true">#</a> 变量路径</h2><p>变量路径通过深入变量的内容，找到其中的列，并最终获得一个值。比如，对于前面的例子如果我们不是赋值<code>4</code>，而是赋值了一个表的值：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> my_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>testuser<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div><p>我们可以使用一个变量路径来访问变量<code>$my_value</code>并只用一步从<code>name</code>列获得数值：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$my_value</span>.name
testuser
</code></pre></div><h2 id="子表达式" tabindex="-1"><a class="header-anchor" href="#子表达式" aria-hidden="true">#</a> 子表达式</h2><p>你总是可以通过用圆括号<code>()</code>来执行一个子表达式并使用其结果。请注意，Nushell 以前的版本（0.32 以前）使用<code>$()</code>。</p>`,15),u=s("code",null,"(ls)",-1),h=s("code",null,"ls",-1),k=s("code",null,"(git branch --show-current)",-1),b=s("code",null,"git",-1),_=s("code",null,"(2 + 3)",-1),g=n(`<p>子表达式也可以是管道，而不仅仅是单个命令。如果我们想得到一个大于 10KB 的文件名列表，我们可以使用子表达式来运行一个管道，并将其赋值给一个变量：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> names_of_big_files <span class="token operator">=</span> <span class="token punctuation">(</span>ls <span class="token operator">|</span> where size <span class="token operator">&gt;</span> 10kb<span class="token punctuation">)</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$names_of_big_files</span>
───┬────────────┬──────┬──────────┬──────────────
 <span class="token comment"># │    name    │ type │   size   │   modified</span>
───┼────────────┼──────┼──────────┼──────────────
 <span class="token number">0</span> │ Cargo.lock │ File │ <span class="token number">155.3</span> KB │ <span class="token number">17</span> hours ago
 <span class="token number">1</span> │ README.md  │ File │  <span class="token number">15.9</span> KB │ <span class="token number">17</span> hours ago
───┴────────────┴──────┴──────────┴──────────────
</code></pre></div><h2 id="子表达式和路径" tabindex="-1"><a class="header-anchor" href="#子表达式和路径" aria-hidden="true">#</a> 子表达式和路径</h2><p>子表达式也支持路径，例如，假设我们想获得当前目录下的文件名列表，其中一个办法是使用管道：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> get name
</code></pre></div><p>我们也可以使用子表达式路径只需一步即可：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token punctuation">(</span>ls<span class="token punctuation">)</span>.name
</code></pre></div><p>这取决于代码的需要和你个人喜欢的编码风格。</p><h2 id="简化子表达式-行条件" tabindex="-1"><a class="header-anchor" href="#简化子表达式-行条件" aria-hidden="true">#</a> 简化子表达式 (行条件)</h2>`,9),m=s("code",null,"ls",-1),v=n(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where size <span class="token operator">&gt;</span> 10kb
</code></pre></div>`,1),f=s("code",null,"where size > 10kb",-1),x=s("code",null,"where",-1),$=s("code",null,"size > 10kb",-1),z=s("code",null,"size",-1),w=s("code",null,"$it.size",-1),y=n(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where <span class="token variable">$it</span>.size <span class="token operator">&gt;</span> 10kb
<span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where <span class="token punctuation">(</span><span class="token variable">$it</span>.size <span class="token operator">&gt;</span> 10kb<span class="token punctuation">)</span>
<span class="token operator">&gt;</span> <span class="token function">ls</span> <span class="token operator">|</span> where <span class="token punctuation">{</span><span class="token operator">|</span><span class="token variable">$x</span><span class="token operator">|</span> <span class="token variable">$x</span>.size <span class="token operator">&gt;</span> 10kb <span class="token punctuation">}</span>
</code></pre></div><p>为了使简化语法正常工作，列名必须出现在操作的左侧（如<code>size &gt; 10kb</code>中的<code>size</code>）。</p>`,2);function N(B,C){const e=r("RouterLink");return l(),c("div",null,[d,s("p",null,[a("括号中包含了一个流水线，该流水线将被执行完毕然后使用结果值。例如，"),u,a("将运行"),o(e,{to:"/book/commands/ls.html"},{default:t(()=>[h]),_:1}),a("命令并返回结果表格，"),k,a("运行外部"),b,a("命令并返回一个包含当前分支名称的字符串。你也可以使用括号来运行数学表达式，如"),_,a("。")]),g,s("p",null,[a("Nushell 支持使用一种简化的方式访问子表达式中的列，你可能已经使用过这个功能了。例如，如果我们想只看到"),o(e,{to:"/book/commands/ls.html"},{default:t(()=>[m]),_:1}),a("中大小至少为 10KB 的行，我们可以通过：")]),v,s("p",null,[f,a("是一个由两部分组成的命令：命令名"),o(e,{to:"/book/commands/where.html"},{default:t(()=>[x]),_:1}),a("和简化的表达式"),$,a("。我们说简化是因为这里的"),z,a("是"),w,a("的简洁版。也可以用以下任何一种方式来写：")]),y])}const V=p(i,[["render",N],["__file","variables_and_subexpressions.html.vue"]]);export{V as default};
