import{_ as l,z as c,A as d,X as e,C as a,T as s,$ as o,a6 as t,Q as p}from"./framework.3d018c9f.js";const r={},i=t(`<h1 id="管道" tabindex="-1"><a class="header-anchor" href="#管道" aria-hidden="true">#</a> 管道</h1><p>Nu 的核心设计之一是管道，这个设计思想可以追溯到几十年前 Unix 背后的一些原始理念。正如 Nu 拓展了 Unix 的单一字符串数据类型一样，Nu 也扩展了管道的概念，使其不仅仅包含文本。</p><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><p>一个管道由三部分组成：输入、过滤器和输出。</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">open</span> <span class="token string">&quot;Cargo.toml&quot;</span> <span class="token operator">|</span> inc package.version <span class="token parameter variable">--minor</span> <span class="token operator">|</span> save <span class="token string">&quot;Cargo_new.toml&quot;</span>
</code></pre></div>`,5),u=e("code",null,'open "Cargo.toml"',-1),_=e("code",null,"ls",-1),h=e("code",null,"inc package.version --minor",-1),m=e("code",null,"inc",-1),k=t(`<p>最后一条命令：<code>save &quot;Cargo_new.toml&quot;</code> 是一个输出（有时称为 &quot;接收者&quot;）。输出从管道中获取输入，并对其进行一些最终操作。在我们的例子中，我们在最后一步把通过管道的内容保存到一个文件中。还有一些其他类型的输出命令可以获取数值并供用户查看。</p><p><code>$in</code> 变量可以将管道收集成一个值，允许你将整个流作为一个参数访问，比如：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token variable">$in</span>.1 * <span class="token variable">$in</span>.2
<span class="token number">6</span>
</code></pre></div><h2 id="多行管道" tabindex="-1"><a class="header-anchor" href="#多行管道" aria-hidden="true">#</a> 多行管道</h2><p>如果一个管道对一行来说有些长，你可以把它放在<code>(</code>和<code>)</code>里，以创建一个子表达式：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>
    <span class="token string">&quot;01/22/2021&quot;</span> <span class="token operator">|</span>
    parse <span class="token string">&quot;{month}/{day}/{year}&quot;</span> <span class="token operator">|</span>
    get year
<span class="token punctuation">)</span>
</code></pre></div>`,6),b=e("h2",{id:"与外部命令交互",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#与外部命令交互","aria-hidden":"true"},"#"),a(" 与外部命令交互")],-1),g=e("p",null,[e("code",null,"internal_command | external_command")],-1),x=e("p",null,[a("数据将从 "),e("code",null,"internal_command"),a(" 流向 "),e("code",null,"external_command"),a("。这些数据将被转换为字符串，以便它们可以被发送到外部命令的"),e("code",null,"stdin"),a("。")],-1),f=e("p",null,[e("code",null,"external_command | internal_command")],-1),v=e("code",null,"internal_command",-1),N=e("code",null,"internal_command",-1),q=e("code",null,"lines",-1),C=t('<p><code>external_command_1 | external_command_2</code></p><p>Nu 在两个外部命令之间以与其他 Shell 相同的方式处理数据管道，比如 Bash。<code>external_command_1</code>的<code>stdout</code>与<code>external_command_2</code>的<code>stdin</code>相连，这让数据在两个命令之间自然流动。</p><h2 id="幕后解说" tabindex="-1"><a class="header-anchor" href="#幕后解说" aria-hidden="true">#</a> 幕后解说</h2>',3),B=e("code",null,"ls",-1),E=e("code",null,"table",-1),y=e("code",null,"table",-1),A=e("p",null,"实际上，该命令：",-1),V=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls
`)])],-1),$=e("p",null,"和以下管道：",-1),w=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls | table
`)])],-1),z=e("p",null,"是一样的。",-1);function T(U,F){const n=p("RouterLink");return c(),d("div",null,[i,e("p",null,[a("第一条命令："),u,a(' 是一个输入（有时也称为 "源" 或 "生产者"），它创建或加载数据，并将其送入管道。管道待处理的值正是来自于此输入。像'),s(n,{to:"/book/commands/ls.html"},{default:o(()=>[_]),_:1}),a("这样的命令也是输入，因为它们从文件系统中获取数据，并通过管道发送以便能被后续使用。")]),e("p",null,[a("第二个命令："),h,a(" 是一个过滤器。过滤器获取输入的数据并对其进行处理。它们可能会修改它（如我们例子中的"),s(n,{to:"/book/commands/inc.html"},{default:o(()=>[m]),_:1}),a("命令），或者在值通过时对其做其他操作，如记录。")]),k,e("p",null,[a("也可以参考 "),s(n,{to:"/zh-CN/book/variables_and_subexpressions.html#%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:o(()=>[a("子表达式")]),_:1})]),b,e("p",null,[a("Nu 命令之间使用 Nu 的数据类型进行通信（见"),s(n,{to:"/zh-CN/book/types_of_data.html"},{default:o(()=>[a("数据类型")]),_:1}),a("），但 Nu 之外的命令呢？让我们看看一些与外部命令交互的例子：")]),g,x,f,e("p",null,[a("从外部命令进入 Nu 的数据将以字节的形式流入，Nushell 将尝试自动将其转换为 UTF-8 文本。如果成功，一个文本数据流将被发送到"),v,a("；如果不成功，一个二进制数据流将被发送到"),N,a("。像"),s(n,{to:"/book/commands/lines.html"},{default:o(()=>[q]),_:1}),a("这样的命令有助于从外部命令接收数据，因为它提供了分离的数据行以供后续使用。")]),C,e("p",null,[a("你可能想知道，既然"),s(n,{to:"/book/commands/ls.html"},{default:o(()=>[B]),_:1}),a("是一个输入而不是一个输出，我们为何能看到一个表格？其实 Nu 使用了另一个叫做"),s(n,{to:"/book/commands/table.html"},{default:o(()=>[E]),_:1}),a("的命令为我们自动添加了这个输出。"),s(n,{to:"/book/commands/table.html"},{default:o(()=>[y]),_:1}),a("命令被附加到任何没有输出的管道上，这使得我们可以看到结果。")]),A,V,$,w,z])}const R=l(r,[["render",T],["__file","pipelines.html.vue"]]);export{R as default};
