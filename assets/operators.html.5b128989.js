import{_ as c,z as i,A as l,X as e,C as t,T as s,$ as d,a6 as o,Q as r}from"./framework.3d018c9f.js";const p={},h=o(`<h1 id="operators" tabindex="-1"><a class="header-anchor" href="#operators" aria-hidden="true">#</a> Operators</h1><p>Nushell supports the following operators for common math, logic, and string operations:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>+</code></td><td>add</td></tr><tr><td><code>-</code></td><td>subtract</td></tr><tr><td><code>*</code></td><td>multiply</td></tr><tr><td><code>/</code></td><td>divide</td></tr><tr><td><code>//</code></td><td>floor division</td></tr><tr><td><code>mod</code></td><td>modulo</td></tr><tr><td><code>**</code></td><td>exponentiation (power)</td></tr><tr><td><code>==</code></td><td>equal</td></tr><tr><td><code>!=</code></td><td>not equal</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&lt;=</code></td><td>less than or equal</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>&gt;=</code></td><td>greater than or equal</td></tr><tr><td><code>=~</code></td><td>regex match / string contains another</td></tr><tr><td><code>!~</code></td><td>inverse regex match / string does <em>not</em> contain another</td></tr><tr><td><code>in</code></td><td>value in list</td></tr><tr><td><code>not-in</code></td><td>value not in list</td></tr><tr><td><code>not</code></td><td>logical not</td></tr><tr><td><code>&amp;&amp;</code>, <code>and</code></td><td>and two Boolean expressions (short-circuits)</td></tr><tr><td><code>||</code>, <code>or</code></td><td>or two Boolean expressions (short-circuits)</td></tr><tr><td><code>xor</code></td><td>exclusive or two boolean expressions</td></tr><tr><td><code>bit-or</code></td><td>bitwise or</td></tr><tr><td><code>bit-xor</code></td><td>bitwise xor</td></tr><tr><td><code>bit-and</code></td><td>bitwise and</td></tr><tr><td><code>bit-shl</code></td><td>bitwise shift left</td></tr><tr><td><code>bit-shr</code></td><td>bitwise shift right</td></tr><tr><td><code>starts-with</code></td><td>string starts with</td></tr><tr><td><code>ends-with</code></td><td>string ends with</td></tr><tr><td><code>++</code></td><td>append lists</td></tr></tbody></table><p>Parentheses can be used for grouping to specify evaluation order or for calling commands and using the results in an expression.</p><h2 id="order-of-operations" tabindex="-1"><a class="header-anchor" href="#order-of-operations" aria-hidden="true">#</a> Order of Operations</h2><p>Operations are evaluated in the following order (from highest precedence to lowest):</p><ul><li>Parentheses (<code>()</code>)</li><li>Exponentiation/Power (<code>**</code>)</li><li>Multiply (<code>*</code>), Divide (<code>/</code>), Integer/Floor Division (<code>//</code>), and Modulo (<code>mod</code>)</li><li>Add (<code>+</code>) and Subtract (<code>-</code>)</li><li>Bit shifting (<code>bit-shl</code>, <code>bit-shr</code>)</li><li>Comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>), membership tests (<code>in</code>, <code>not-in</code>, <code>starts-with</code>, <code>ends-with</code>), regex matching (<code>=~</code>, <code>!~</code>), and list appending (<code>++</code>)</li><li>Bitwise and (<code>bit-and</code>)</li><li>Bitwise xor (<code>bit-xor</code>)</li><li>Bitwise or (<code>bit-or</code>)</li><li>Logical and (<code>&amp;&amp;</code>, <code>and</code>)</li><li>Logical xor (<code>xor</code>)</li><li>Logical or (<code>||</code>, <code>or</code>)</li><li>Assignment operations</li></ul><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; 3 * (1 + 2)
9
</code></pre></div><h2 id="types" tabindex="-1"><a class="header-anchor" href="#types" aria-hidden="true">#</a> Types</h2><p>Not all operations make sense for all data types. If you attempt to perform an operation on non-compatible data types, you will be met with an error message that should explain what went wrong:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; &quot;spam&quot; - 1
Error: nu::parser::unsupported_operation (link)

  × Types mismatched for operation.
   ╭─[entry #49:1:1]
 1 │ &quot;spam&quot; - 1
   · ───┬── ┬ ┬
   ·    │   │ ╰── int
   ·    │   ╰── doesn&#39;t support these values.
   ·    ╰── string
   ╰────
  help: Change string or int to be the right types and try again.
</code></pre></div><p>The rules might sometimes feel a bit strict, but on the other hand there should be less unexpected side effects.</p><h2 id="regular-expression-string-contains-operators" tabindex="-1"><a class="header-anchor" href="#regular-expression-string-contains-operators" aria-hidden="true">#</a> Regular Expression / string-contains Operators</h2>`,13),u=e("code",null,"=~",-1),g=e("code",null,"!~",-1),m={href:"https://cheatography.com/davechild/cheat-sheets/regular-expressions/",target:"_blank",rel:"noopener noreferrer"},f=o(`<ul><li><code>string =~ pattern</code> returns <strong>true</strong> if <code>string</code> contains a match for <code>pattern</code>, and <strong>false</strong> otherwise.</li><li><code>string !~ pattern</code> returns <strong>false</strong> if <code>string</code> contains a match for <code>pattern</code>, and <strong>true</strong> otherwise.</li></ul><p>For example:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>foobarbaz <span class="token operator">=~</span> bar <span class="token comment"># returns true</span>
foobarbaz <span class="token operator">!</span>~ bar <span class="token comment"># returns false</span>
<span class="token function">ls</span> <span class="token operator">|</span> where name <span class="token operator">=~</span> ^nu <span class="token comment"># returns all files whose names start with &quot;nu&quot;</span>
</code></pre></div>`,3),b={href:"https://docs.rs/regex/latest/regex/struct.Regex.html#method.is_match",target:"_blank",rel:"noopener noreferrer"},x=e("code",null,"is_match()",-1),_=o(`<h2 id="case-sensitivity" tabindex="-1"><a class="header-anchor" href="#case-sensitivity" aria-hidden="true">#</a> Case Sensitivity</h2><p>Operators are usually case-sensitive when operating on strings. There are a few ways to do case-insensitive work instead:</p><ol><li>In the regular expression operators, specify the <code>(?i)</code> case-insensitive mode modifier:</li></ol><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;FOO&quot;</span> <span class="token operator">=~</span> <span class="token string">&quot;foo&quot;</span> <span class="token comment"># returns false</span>
<span class="token string">&quot;FOO&quot;</span> <span class="token operator">=~</span> <span class="token string">&quot;(?i)foo&quot;</span> <span class="token comment"># returns true</span>
</code></pre></div>`,4),w={start:"2"},k=e("code",null,"str contains",-1),v=e("code",null,"--insensitive",-1),y=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;FOO&quot;</span> <span class="token operator">|</span> str contains <span class="token parameter variable">--insensitive</span> <span class="token string">&quot;foo&quot;</span>
</code></pre></div>`,1),q={start:"3"},O=e("code",null,"str downcase",-1),B=o(`<div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span><span class="token string">&quot;FOO&quot;</span> <span class="token operator">|</span> str downcase<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">&quot;Foo&quot;</span> <span class="token operator">|</span> str downcase<span class="token punctuation">)</span>
</code></pre></div>`,1);function C(F,L){const a=r("ExternalLinkIcon"),n=r("RouterLink");return i(),l("div",null,[h,e("p",null,[t("The "),u,t(" and "),g,t(" operators provide a convenient way to evaluate "),e("a",m,[t("regular expressions"),s(a)]),t(". You don't need to know regular expressions to use them - they're also an easy way to check whether 1 string contains another.")]),f,e("p",null,[t("Both operators use "),e("a",b,[t("the Rust regex crate's "),x,t(" function"),s(a)]),t(".")]),_,e("ol",w,[e("li",null,[t("Use the "),s(n,{to:"/book/commands/str_contains.html"},{default:d(()=>[k]),_:1}),t(" command's "),v,t(" flag:")])]),y,e("ol",q,[e("li",null,[t("Convert strings to lowercase with "),s(n,{to:"/book/commands/str_downcase.html"},{default:d(()=>[O]),_:1}),t(" before comparing:")])]),B])}const E=c(p,[["render",C],["__file","operators.html.vue"]]);export{E as default};
