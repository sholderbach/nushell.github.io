import{_ as e,z as a,A as o,a6 as s}from"./framework.3d018c9f.js";const t={},r=s(`<h1 id="shells" tabindex="-1"><a class="header-anchor" href="#shells" aria-hidden="true">#</a> Shells</h1><p>Talvez um conceito único de Nu seja o de <code>shells</code>, apesar de a ideia de trabalhar em diversos lugares ao mesmo tempo em um shell é bem comum (via pushd/popd, telas, e mais). O que talvez torne o Nu um pouco diferente é que o seu conceito de <code>shells</code> é de ambas plataformas e funciona tanto no sistema de arquivos quanto dentro de valores.</p><p><strong>Nota:</strong> O conceito de um Value Shell é um de muitos fatores de design abertos e está sujeito a mudanças no futuro.</p><p>Um <strong>Shell</strong> é uma interface semelhante a um sistema de arquivos que descreve um conjunto de operações de arquivos e como operá-los, incluindo: <code>cd</code>, <code>ls</code>, <code>mkdir</code>, <code>rm</code>, <code>cp</code>, e <code>mv</code>. Nem todos os tipos de shells suportam todas as operações de arquivos, mas as operações de arquivos servem para tentar descrever o que um shell deveria fazer.</p><p>Os dois tipos de shell atualmente disponíveis são FilesystemShell and ValueShell, mas outros tipos de shells já foram discutidos.</p><h2 id="filesystem-shell" tabindex="-1"><a class="header-anchor" href="#filesystem-shell" aria-hidden="true">#</a> Filesystem Shell</h2><p>O filesystem shell é um shell que trabalha diretamente com o sistema de arquivos e um arquivo correspondente. Por padrão, Nu inicia com um único filesystem shell no diretório atual.</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; shells
━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━
   │ name       │ path
───┼────────────┼────────────────
 X │ filesystem │ /home/jonathan
━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━
</code></pre></div><p>Podemos adicionar mais um filesystem shell para essa lista usando o comando <code>enter</code>. Isso vai adicionar uma nova combinação shell+path para o nosso buffer circular de shells.</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; enter Source
/home/jonathan/Source&gt; shells
━━━┯━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━
 # │   │ name       │ path
───┼───┼────────────┼───────────────────────
 0 │   │ filesystem │ /home/jonathan
 1 │ X │ filesystem │ /home/jonathan/Source
━━━┷━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━
</code></pre></div><p>Dessa forma, você pode intercalar entre diretórios de trabalho. Note que atualmente o Nu não permite intercalar entre aplicações em execução, apenas diretórios de trabalho.</p><p><strong>Limitações</strong></p><p>Existem algumas limitações no filesystem shell no seu estado atual de desenvolvimento. Uma das limitações é que não é simples adicionar múltiplos caminhos no buffer circular de uma só vez (por exemplo: <code>enter $it</code>), já que cada adição ao buffer circular vai mudar o diretório atual. Essa limitação não é inerente ao design do buffer circular e em um design futuro seria desejável separar <code>enter</code> da mudança de diretório atual.</p><h2 id="value-shell" tabindex="-1"><a class="header-anchor" href="#value-shell" aria-hidden="true">#</a> Value Shell</h2><p>O Value Shell da a habilidade de explorar um valor estruturado internamente ao carregar um arquivo e tratando seu conteúdo como se fosse um sistema de arquivos. Isso permite explorar os seus dados como um dos shells no buffer circular.</p><p>A implementação atual do Value Shell é limitada ao sub-conjunto de operações de leitura de operações de arquivo, isto é: <code>cd</code> e <code>ls</code>. Em designs futuros seria interessante expandir isso, mas existem perguntas abertas sobre alterar um arquivo aberto com <code>enter</code> e como o resto do ambiente observa essas mudanças (o que acontece se você usar enter no arquivo sendo usado pelo <code>config</code>?)</p><p>Em um Value Shell, o comando <code>cd</code>muda o caminho sendo observado como o &quot;diretório atual&quot; no objeto, mas na verdade é o caminho de campo. Isso significa que o caminho &quot;/abc/def&quot; é o caminho &quot;abc.def&quot; fora do Value Shell.</p>`,17),d=[r];function l(i,n){return a(),o("div",null,d)}const c=e(t,[["render",l],["__file","shells.html.vue"]]);export{c as default};
