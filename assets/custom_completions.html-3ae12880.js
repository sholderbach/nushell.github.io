import{_ as c,M as p,p as l,q as u,Q as a,t as n,N as t,U as e,a1 as o}from"./framework-344bb0e4.js";const i={},d=a("h1",{id:"自定义补全",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#自定义补全","aria-hidden":"true"},"#"),n(" 自定义补全")],-1),r=a("code",null,"extern",-1),h=o(`<p>自定义命令有两个部分：处理补全的命令和使用<code>@</code>将此命令附加到另一个命令的类型中。</p><h2 id="自定义补全例子" tabindex="-1"><a class="header-anchor" href="#自定义补全例子" aria-hidden="true">#</a> 自定义补全例子</h2><p>我们来看一个例子：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> def animals <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token string">&quot;cat&quot;</span>, <span class="token string">&quot;dog&quot;</span>, <span class="token string">&quot;eel&quot;</span> <span class="token punctuation">]</span> <span class="token punctuation">}</span>
<span class="token operator">&gt;</span> def my-command <span class="token punctuation">[</span>animal: string@animals<span class="token punctuation">]</span> <span class="token punctuation">{</span> print <span class="token variable">$animal</span> <span class="token punctuation">}</span>
<span class="token operator">&gt;|</span> my-command
<span class="token function">cat</span>                 dog                 eel
</code></pre></div><p>在第一行中，我们创建了一个自定义命令，将返回三个不同动物的列表。这些是我们想在补全中使用的值。一旦我们创建了这个命令，我们就可以用它来为其他自定义命令和 <code>extern</code> 提供补全。</p><p>在第二行，我们使用<code>string@animals</code>。这告诉了 Nushell 两件事：用于类型检查的参数的形状，以及如果用户想在该位置补全输入值，需要使用的自定义完成。</p><p>在第三行，我们输入我们的自定义命令的名称<code>my-command</code>，然后输入空格，再输入<code>&lt;tab&gt;</code>键，就可以触发我们的自动补全功能。自定义补全的工作方式与系统中的其他补全方式相同，比如允许你输入<code>e</code>，然后按<code>&lt;tab&gt;</code>键，得到 &quot;eel&quot; 自动补全。</p><h2 id="模块和自定义补全" tabindex="-1"><a class="header-anchor" href="#模块和自定义补全" aria-hidden="true">#</a> 模块和自定义补全</h2><p>你可能更喜欢让你的自定义补全远离你的代码的公共 API。为此，你可以将模块和自定义补全结合起来。</p><p>让我们把上面的例子放在一个模块中：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>module commands <span class="token punctuation">{</span>
    def animals <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token string">&quot;cat&quot;</span>, <span class="token string">&quot;dog&quot;</span>, <span class="token string">&quot;eel&quot;</span> <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token builtin class-name">export</span> def my-command <span class="token punctuation">[</span>animal: string@animals<span class="token punctuation">]</span> <span class="token punctuation">{</span>
        print <span class="token variable">$animal</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在我们的模块中，我们选择只导出自定义命令<code>my-command</code>，而不导出自定义补全<code>animals</code>。这使得本模块的用户可以调用命令，甚至使用自定义补全逻辑，而不需要访问自定义补全。这样可以让 API 更干净，同时仍然提供所有相同的好处。</p><p>这是可能的，因为使用<code>@</code>的自定义补全标签在命令第一次被解析时就被锁定了。</p><h2 id="自定义补全和-extern" tabindex="-1"><a class="header-anchor" href="#自定义补全和-extern" aria-hidden="true">#</a> 自定义补全和 <code>extern</code></h2>`,14),m=a("code",null,"extern",-1),k=a("code",null,"@",-1),g=a("code",null,"extern",-1),_=o(`<p>如果你仔细看一下默认配置中的例子，你会看到这个：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">export</span> extern <span class="token string">&quot;git push&quot;</span> <span class="token punctuation">[</span>
    remote?: string@<span class="token string">&quot;nu-complete git remotes&quot;</span>, <span class="token comment"># the name of the remote</span>
    refspec?: string@<span class="token string">&quot;nu-complete git branches&quot;</span># the branch / refspec
    <span class="token punctuation">..</span>.
<span class="token punctuation">]</span>
</code></pre></div><p>自定义补全在这个例子中的作用与前面的例子中的作用相同。上面的例子根据用户当前所处的位置，调用了两个不同的自定义补全。</p>`,3);function x(f,q){const s=p("RouterLink");return l(),u("div",null,[d,a("p",null,[n("自定义补全允许你混合使用 Nushell 的两个功能：自定义命令和补全。有了它们，你就能够创建支持对位置参数和标志(Flags)参数进行自动补全的命令。这些自定义补全既适用于自定义命令，也适用于 "),t(s,{to:"/zh-CN/book/externs.html"},{default:e(()=>[n("已知的外部或"),r,n("命令")]),_:1}),n("。")]),h,a("p",null,[n("一个强大的组合是为 "),t(s,{to:"/zh-CN/book/externs.html"},{default:e(()=>[n("已知的"),m,n("命令")]),_:1}),n(" 添加自定义补全。这些工作方式与向自定义命令添加自定义补全的方式相同：创建自定义补全，然后用"),k,n("附加到 "),g,n(" 的一个位置参数或标志参数的类型中。")]),_])}const v=c(i,[["render",x],["__file","custom_completions.html.vue"]]);export{v as default};
